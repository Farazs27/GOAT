---
phase: 01-clinical-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/src/app/api/patients/[id]/odontogram/route.ts
  - apps/web/src/app/api/patients/[id]/teeth/[toothNumber]/route.ts
  - apps/web/src/app/api/patients/[id]/teeth/[toothNumber]/treatments/route.ts
autonomous: true
requirements:
  - CLIN-01
  - CLIN-02

must_haves:
  truths:
    - "Saving a restoration in the RestorationPanel creates a Treatment record in the database linked to the tooth"
    - "Saving a restoration creates ToothSurface records linked to the Treatment via treatmentId"
    - "Changing tooth status (MISSING/IMPLANT/ENDO) creates a Treatment record documenting the status change"
    - "Treatment history for a tooth shows actual Treatment records with performer, date, surfaces, and description"
    - "Odontogram visually refreshes after saving (existing refresh cycle works, no changes needed)"
  artifacts:
    - path: "apps/web/src/app/api/patients/[id]/odontogram/route.ts"
      provides: "POST handler that creates Treatment + linked ToothSurface records in a transaction"
      contains: "prisma.$transaction"
    - path: "apps/web/src/app/api/patients/[id]/teeth/[toothNumber]/route.ts"
      provides: "PATCH handler that creates a Treatment record for status changes"
      contains: "treatment.create"
    - path: "apps/web/src/app/api/patients/[id]/teeth/[toothNumber]/treatments/route.ts"
      provides: "GET handler that queries actual Treatment records instead of grouping surfaces by timestamp"
      contains: "prisma.treatment.findMany"
  key_links:
    - from: "apps/web/src/app/api/patients/[id]/odontogram/route.ts"
      to: "prisma.treatment + prisma.toothSurface"
      via: "Transaction creating Treatment then ToothSurface records with treatmentId FK"
      pattern: "treatmentId.*treatment\\.id"
    - from: "apps/web/src/app/api/patients/[id]/teeth/[toothNumber]/route.ts"
      to: "prisma.treatment"
      via: "Treatment record creation on tooth status change"
      pattern: "treatment\\.create"
    - from: "apps/web/src/app/api/patients/[id]/teeth/[toothNumber]/treatments/route.ts"
      to: "prisma.treatment"
      via: "Direct Treatment query replacing surface-grouping hack"
      pattern: "prisma\\.treatment\\.findMany"
---

<objective>
Wire Treatment record creation into the odontogram save flow and fix the treatment history endpoint to use actual Treatment records.

Purpose: Currently, saving restorations creates ToothSurface records but no Treatment records, breaking treatment history and billing linkage. Tooth status changes (MISSING/IMPLANT/ENDO) also create no Treatment records. The history endpoint fakes entries by grouping surfaces by timestamp. This plan fixes all three gaps.

Output: Fully functional clinical recording flow where every save action creates proper Treatment records, and treatment history shows real data.
</objective>

<execution_context>
@/Users/farazsharifi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/farazsharifi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-clinical-foundation/01-RESEARCH.md
@packages/database/prisma/schema.prisma
@apps/web/src/app/api/patients/[id]/odontogram/route.ts
@apps/web/src/app/api/patients/[id]/teeth/[toothNumber]/route.ts
@apps/web/src/app/api/patients/[id]/teeth/[toothNumber]/treatments/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire Treatment record creation into odontogram POST and teeth PATCH routes</name>
  <files>
    apps/web/src/app/api/patients/[id]/odontogram/route.ts
    apps/web/src/app/api/patients/[id]/teeth/[toothNumber]/route.ts
  </files>
  <action>
**File 1: `apps/web/src/app/api/patients/[id]/odontogram/route.ts` — POST handler**

Wrap the existing tooth upsert + surface creation in a `prisma.$transaction()`. Inside the transaction:

1. Upsert the tooth (existing logic, unchanged)
2. Create a `Treatment` record:
   ```
   practiceId: user.practiceId
   patientId: id
   performedBy: user.id
   toothId: tooth.id
   description: `${restorationType || treatmentType} — ${(surfaces || []).join(',')}` (use em-dash)
   status: 'COMPLETED'
   performedAt: new Date()
   ```
3. Create `ToothSurface` records (existing logic) but ADD `treatmentId: treatment.id` to each record's data
4. After the transaction, fetch the updated tooth with surfaces (existing logic, unchanged)

Keep the GET handler completely unchanged.

**File 2: `apps/web/src/app/api/patients/[id]/teeth/[toothNumber]/route.ts` — PATCH handler**

After the existing tooth upsert, add a Treatment record creation:
```
await prisma.treatment.create({
  data: {
    practiceId: user.practiceId,
    patientId: id,
    performedBy: user.id,
    toothId: tooth.id,
    description: `Status: ${body.status}`,
    status: 'COMPLETED',
    performedAt: new Date(),
  },
});
```

This ensures status changes (MISSING, IMPLANT, ENDO, CROWN, etc.) are recorded as Treatment entries for history and future billing linkage.

**IMPORTANT:** Do NOT change the request/response shape of either endpoint. The frontend already works with the current response format. Only add Treatment record creation internally.
  </action>
  <verify>
Run `pnpm --filter @dentflow/web build` to confirm no TypeScript errors. Manually verify the routes by reading the modified files and confirming: (a) POST odontogram uses $transaction, creates Treatment before surfaces, passes treatmentId; (b) PATCH teeth creates a Treatment record after upsert.
  </verify>
  <done>
POST /api/patients/{id}/odontogram creates a Treatment record and links ToothSurface records to it via treatmentId. PATCH /api/patients/{id}/teeth/{toothNumber} creates a Treatment record for every status change. Both endpoints return the same response shape as before.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace treatment history endpoint with real Treatment queries</name>
  <files>
    apps/web/src/app/api/patients/[id]/teeth/[toothNumber]/treatments/route.ts
  </files>
  <action>
Rewrite the GET handler to query actual Treatment records instead of grouping surfaces by timestamp.

Replace the current logic (surface grouping by `recordedAt`) with:

1. Find the tooth (existing logic, unchanged)
2. Query treatments:
   ```typescript
   const treatments = await prisma.treatment.findMany({
     where: { toothId: tooth.id, practiceId: user.practiceId },
     include: {
       performer: { select: { firstName: true, lastName: true } },
       toothSurfaces: { select: { surface: true, condition: true, material: true, restorationType: true } },
     },
     orderBy: { performedAt: 'desc' },
   });
   ```
3. Map to response format matching what the frontend expects:
   ```typescript
   const result = treatments.map((t) => ({
     id: t.id,
     date: (t.performedAt || t.createdAt).toISOString(),
     description: t.description,
     nzaCode: '', // Will be populated in Phase 3 (billing)
     performedBy: t.performer
       ? `${t.performer.firstName ?? ''} ${t.performer.lastName ?? ''}`.trim()
       : 'Onbekend',
     surfaces: t.toothSurfaces.map((s) => s.surface),
   }));
   ```
4. Return `{ treatments: result }`

**Fallback:** For backward compatibility with old data that has surfaces but no Treatment records, add a fallback: if `treatments` is empty, fall back to the old surface-grouping logic. This ensures existing data still displays correctly until new Treatment records are created.

The response shape `{ treatments: Array<{ id, date, description, nzaCode, performedBy, surfaces }> }` must remain identical.
  </action>
  <verify>
Run `pnpm --filter @dentflow/web build` to confirm no TypeScript errors. Read the modified file and verify: (a) it queries `prisma.treatment.findMany` with `toothSurfaces` include, (b) maps to the same response shape, (c) has fallback for legacy surface-only data.
  </verify>
  <done>
GET /api/patients/{id}/teeth/{toothNumber}/treatments returns Treatment records with performer names and linked surfaces. Old surface-only data still renders via fallback. Response shape unchanged.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @dentflow/web build` passes without errors
2. POST /api/patients/{id}/odontogram creates Treatment + linked ToothSurface records (verified by reading code)
3. PATCH /api/patients/{id}/teeth/{toothNumber} creates Treatment for status changes (verified by reading code)
4. GET /api/patients/{id}/teeth/{toothNumber}/treatments queries real Treatment records (verified by reading code)
5. All response shapes unchanged — frontend works without modification
</verification>

<success_criteria>
- Build passes: `pnpm --filter @dentflow/web build` exits 0
- Treatment records are created on every save action (restoration + status change)
- ToothSurface records are linked to Treatment via treatmentId
- Treatment history endpoint returns real Treatment data
- No frontend changes needed — existing UI continues working
</success_criteria>

<output>
After completion, create `.planning/phases/01-clinical-foundation/01-01-SUMMARY.md`
</output>
