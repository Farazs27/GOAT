
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.4.0
 * Query Engine version: ab56fe763f921d033a6c195e7ddeb3e255bdbb57
 */
export const prismaVersion: PrismaVersion = {
  client: "7.4.0",
  engine: "ab56fe763f921d033a6c195e7ddeb3e255bdbb57"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  Practice: 'Practice',
  User: 'User',
  Patient: 'Patient',
  Tooth: 'Tooth',
  ToothSurface: 'ToothSurface',
  TreatmentPlan: 'TreatmentPlan',
  Treatment: 'Treatment',
  ClinicalNote: 'ClinicalNote',
  NoteFlag: 'NoteFlag',
  Appointment: 'Appointment',
  PractitionerSchedule: 'PractitionerSchedule',
  ScheduleException: 'ScheduleException',
  NzaCode: 'NzaCode',
  Invoice: 'Invoice',
  InvoiceLine: 'InvoiceLine',
  Payment: 'Payment',
  InsuranceClaim: 'InsuranceClaim',
  ConsentTemplate: 'ConsentTemplate',
  ConsentForm: 'ConsentForm',
  Document: 'Document',
  AuditLog: 'AuditLog',
  Notification: 'Notification',
  Credential: 'Credential',
  Prescription: 'Prescription',
  PeriodontalChart: 'PeriodontalChart',
  PatientImage: 'PatientImage',
  Anamnesis: 'Anamnesis',
  Message: 'Message',
  Referral: 'Referral',
  Complaint: 'Complaint',
  EmailThread: 'EmailThread',
  EmailMessage: 'EmailMessage',
  WhatsAppConversation: 'WhatsAppConversation',
  WhatsAppMessage: 'WhatsAppMessage',
  PatientCategory: 'PatientCategory',
  CustomCodeCategory: 'CustomCodeCategory',
  CustomCodeCategoryCode: 'CustomCodeCategoryCode',
  DsdDesign: 'DsdDesign',
  DsdDesignVersion: 'DsdDesignVersion',
  Conversation: 'Conversation',
  ConversationMessage: 'ConversationMessage',
  MessageAttachment: 'MessageAttachment',
  DentistTask: 'DentistTask',
  AiChatSession: 'AiChatSession',
  AiChatMessage: 'AiChatMessage',
  PatientNudge: 'PatientNudge',
  StaffChat: 'StaffChat',
  StaffChatMember: 'StaffChatMember',
  StaffChatMessage: 'StaffChatMessage',
  PerioSession: 'PerioSession',
  PerioSite: 'PerioSite',
  PerioProtocol: 'PerioProtocol',
  RecallSchedule: 'RecallSchedule'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "practice" | "user" | "patient" | "tooth" | "toothSurface" | "treatmentPlan" | "treatment" | "clinicalNote" | "noteFlag" | "appointment" | "practitionerSchedule" | "scheduleException" | "nzaCode" | "invoice" | "invoiceLine" | "payment" | "insuranceClaim" | "consentTemplate" | "consentForm" | "document" | "auditLog" | "notification" | "credential" | "prescription" | "periodontalChart" | "patientImage" | "anamnesis" | "message" | "referral" | "complaint" | "emailThread" | "emailMessage" | "whatsAppConversation" | "whatsAppMessage" | "patientCategory" | "customCodeCategory" | "customCodeCategoryCode" | "dsdDesign" | "dsdDesignVersion" | "conversation" | "conversationMessage" | "messageAttachment" | "dentistTask" | "aiChatSession" | "aiChatMessage" | "patientNudge" | "staffChat" | "staffChatMember" | "staffChatMessage" | "perioSession" | "perioSite" | "perioProtocol" | "recallSchedule"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    Practice: {
      payload: Prisma.$PracticePayload<ExtArgs>
      fields: Prisma.PracticeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PracticeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PracticePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PracticeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PracticePayload>
        }
        findFirst: {
          args: Prisma.PracticeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PracticePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PracticeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PracticePayload>
        }
        findMany: {
          args: Prisma.PracticeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PracticePayload>[]
        }
        create: {
          args: Prisma.PracticeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PracticePayload>
        }
        createMany: {
          args: Prisma.PracticeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PracticeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PracticePayload>[]
        }
        delete: {
          args: Prisma.PracticeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PracticePayload>
        }
        update: {
          args: Prisma.PracticeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PracticePayload>
        }
        deleteMany: {
          args: Prisma.PracticeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PracticeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PracticeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PracticePayload>[]
        }
        upsert: {
          args: Prisma.PracticeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PracticePayload>
        }
        aggregate: {
          args: Prisma.PracticeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePractice>
        }
        groupBy: {
          args: Prisma.PracticeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PracticeGroupByOutputType>[]
        }
        count: {
          args: Prisma.PracticeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PracticeCountAggregateOutputType> | number
        }
      }
    }
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    Patient: {
      payload: Prisma.$PatientPayload<ExtArgs>
      fields: Prisma.PatientFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PatientFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>
        }
        findFirst: {
          args: Prisma.PatientFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>
        }
        findMany: {
          args: Prisma.PatientFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>[]
        }
        create: {
          args: Prisma.PatientCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>
        }
        createMany: {
          args: Prisma.PatientCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>[]
        }
        delete: {
          args: Prisma.PatientDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>
        }
        update: {
          args: Prisma.PatientUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>
        }
        deleteMany: {
          args: Prisma.PatientDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PatientUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>[]
        }
        upsert: {
          args: Prisma.PatientUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>
        }
        aggregate: {
          args: Prisma.PatientAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePatient>
        }
        groupBy: {
          args: Prisma.PatientGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PatientGroupByOutputType>[]
        }
        count: {
          args: Prisma.PatientCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PatientCountAggregateOutputType> | number
        }
      }
    }
    Tooth: {
      payload: Prisma.$ToothPayload<ExtArgs>
      fields: Prisma.ToothFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ToothFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ToothFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothPayload>
        }
        findFirst: {
          args: Prisma.ToothFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ToothFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothPayload>
        }
        findMany: {
          args: Prisma.ToothFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothPayload>[]
        }
        create: {
          args: Prisma.ToothCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothPayload>
        }
        createMany: {
          args: Prisma.ToothCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ToothCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothPayload>[]
        }
        delete: {
          args: Prisma.ToothDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothPayload>
        }
        update: {
          args: Prisma.ToothUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothPayload>
        }
        deleteMany: {
          args: Prisma.ToothDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ToothUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ToothUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothPayload>[]
        }
        upsert: {
          args: Prisma.ToothUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothPayload>
        }
        aggregate: {
          args: Prisma.ToothAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTooth>
        }
        groupBy: {
          args: Prisma.ToothGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ToothGroupByOutputType>[]
        }
        count: {
          args: Prisma.ToothCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ToothCountAggregateOutputType> | number
        }
      }
    }
    ToothSurface: {
      payload: Prisma.$ToothSurfacePayload<ExtArgs>
      fields: Prisma.ToothSurfaceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ToothSurfaceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothSurfacePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ToothSurfaceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothSurfacePayload>
        }
        findFirst: {
          args: Prisma.ToothSurfaceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothSurfacePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ToothSurfaceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothSurfacePayload>
        }
        findMany: {
          args: Prisma.ToothSurfaceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothSurfacePayload>[]
        }
        create: {
          args: Prisma.ToothSurfaceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothSurfacePayload>
        }
        createMany: {
          args: Prisma.ToothSurfaceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ToothSurfaceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothSurfacePayload>[]
        }
        delete: {
          args: Prisma.ToothSurfaceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothSurfacePayload>
        }
        update: {
          args: Prisma.ToothSurfaceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothSurfacePayload>
        }
        deleteMany: {
          args: Prisma.ToothSurfaceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ToothSurfaceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ToothSurfaceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothSurfacePayload>[]
        }
        upsert: {
          args: Prisma.ToothSurfaceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ToothSurfacePayload>
        }
        aggregate: {
          args: Prisma.ToothSurfaceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateToothSurface>
        }
        groupBy: {
          args: Prisma.ToothSurfaceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ToothSurfaceGroupByOutputType>[]
        }
        count: {
          args: Prisma.ToothSurfaceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ToothSurfaceCountAggregateOutputType> | number
        }
      }
    }
    TreatmentPlan: {
      payload: Prisma.$TreatmentPlanPayload<ExtArgs>
      fields: Prisma.TreatmentPlanFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TreatmentPlanFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPlanPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TreatmentPlanFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPlanPayload>
        }
        findFirst: {
          args: Prisma.TreatmentPlanFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPlanPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TreatmentPlanFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPlanPayload>
        }
        findMany: {
          args: Prisma.TreatmentPlanFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPlanPayload>[]
        }
        create: {
          args: Prisma.TreatmentPlanCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPlanPayload>
        }
        createMany: {
          args: Prisma.TreatmentPlanCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TreatmentPlanCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPlanPayload>[]
        }
        delete: {
          args: Prisma.TreatmentPlanDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPlanPayload>
        }
        update: {
          args: Prisma.TreatmentPlanUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPlanPayload>
        }
        deleteMany: {
          args: Prisma.TreatmentPlanDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TreatmentPlanUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TreatmentPlanUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPlanPayload>[]
        }
        upsert: {
          args: Prisma.TreatmentPlanUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPlanPayload>
        }
        aggregate: {
          args: Prisma.TreatmentPlanAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTreatmentPlan>
        }
        groupBy: {
          args: Prisma.TreatmentPlanGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreatmentPlanGroupByOutputType>[]
        }
        count: {
          args: Prisma.TreatmentPlanCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreatmentPlanCountAggregateOutputType> | number
        }
      }
    }
    Treatment: {
      payload: Prisma.$TreatmentPayload<ExtArgs>
      fields: Prisma.TreatmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TreatmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TreatmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPayload>
        }
        findFirst: {
          args: Prisma.TreatmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TreatmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPayload>
        }
        findMany: {
          args: Prisma.TreatmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPayload>[]
        }
        create: {
          args: Prisma.TreatmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPayload>
        }
        createMany: {
          args: Prisma.TreatmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TreatmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPayload>[]
        }
        delete: {
          args: Prisma.TreatmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPayload>
        }
        update: {
          args: Prisma.TreatmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPayload>
        }
        deleteMany: {
          args: Prisma.TreatmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TreatmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TreatmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPayload>[]
        }
        upsert: {
          args: Prisma.TreatmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreatmentPayload>
        }
        aggregate: {
          args: Prisma.TreatmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTreatment>
        }
        groupBy: {
          args: Prisma.TreatmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreatmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.TreatmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreatmentCountAggregateOutputType> | number
        }
      }
    }
    ClinicalNote: {
      payload: Prisma.$ClinicalNotePayload<ExtArgs>
      fields: Prisma.ClinicalNoteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ClinicalNoteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicalNotePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ClinicalNoteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
        }
        findFirst: {
          args: Prisma.ClinicalNoteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicalNotePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ClinicalNoteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
        }
        findMany: {
          args: Prisma.ClinicalNoteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicalNotePayload>[]
        }
        create: {
          args: Prisma.ClinicalNoteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
        }
        createMany: {
          args: Prisma.ClinicalNoteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ClinicalNoteCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicalNotePayload>[]
        }
        delete: {
          args: Prisma.ClinicalNoteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
        }
        update: {
          args: Prisma.ClinicalNoteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
        }
        deleteMany: {
          args: Prisma.ClinicalNoteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ClinicalNoteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ClinicalNoteUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicalNotePayload>[]
        }
        upsert: {
          args: Prisma.ClinicalNoteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
        }
        aggregate: {
          args: Prisma.ClinicalNoteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateClinicalNote>
        }
        groupBy: {
          args: Prisma.ClinicalNoteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ClinicalNoteGroupByOutputType>[]
        }
        count: {
          args: Prisma.ClinicalNoteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ClinicalNoteCountAggregateOutputType> | number
        }
      }
    }
    NoteFlag: {
      payload: Prisma.$NoteFlagPayload<ExtArgs>
      fields: Prisma.NoteFlagFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NoteFlagFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteFlagPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NoteFlagFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteFlagPayload>
        }
        findFirst: {
          args: Prisma.NoteFlagFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteFlagPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NoteFlagFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteFlagPayload>
        }
        findMany: {
          args: Prisma.NoteFlagFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteFlagPayload>[]
        }
        create: {
          args: Prisma.NoteFlagCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteFlagPayload>
        }
        createMany: {
          args: Prisma.NoteFlagCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NoteFlagCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteFlagPayload>[]
        }
        delete: {
          args: Prisma.NoteFlagDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteFlagPayload>
        }
        update: {
          args: Prisma.NoteFlagUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteFlagPayload>
        }
        deleteMany: {
          args: Prisma.NoteFlagDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NoteFlagUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NoteFlagUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteFlagPayload>[]
        }
        upsert: {
          args: Prisma.NoteFlagUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteFlagPayload>
        }
        aggregate: {
          args: Prisma.NoteFlagAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNoteFlag>
        }
        groupBy: {
          args: Prisma.NoteFlagGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NoteFlagGroupByOutputType>[]
        }
        count: {
          args: Prisma.NoteFlagCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NoteFlagCountAggregateOutputType> | number
        }
      }
    }
    Appointment: {
      payload: Prisma.$AppointmentPayload<ExtArgs>
      fields: Prisma.AppointmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        findFirst: {
          args: Prisma.AppointmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        findMany: {
          args: Prisma.AppointmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
        }
        create: {
          args: Prisma.AppointmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        createMany: {
          args: Prisma.AppointmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
        }
        delete: {
          args: Prisma.AppointmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        update: {
          args: Prisma.AppointmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        deleteMany: {
          args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
        }
        upsert: {
          args: Prisma.AppointmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>
        }
        aggregate: {
          args: Prisma.AppointmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAppointment>
        }
        groupBy: {
          args: Prisma.AppointmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AppointmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.AppointmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AppointmentCountAggregateOutputType> | number
        }
      }
    }
    PractitionerSchedule: {
      payload: Prisma.$PractitionerSchedulePayload<ExtArgs>
      fields: Prisma.PractitionerScheduleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PractitionerScheduleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PractitionerSchedulePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PractitionerScheduleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PractitionerSchedulePayload>
        }
        findFirst: {
          args: Prisma.PractitionerScheduleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PractitionerSchedulePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PractitionerScheduleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PractitionerSchedulePayload>
        }
        findMany: {
          args: Prisma.PractitionerScheduleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PractitionerSchedulePayload>[]
        }
        create: {
          args: Prisma.PractitionerScheduleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PractitionerSchedulePayload>
        }
        createMany: {
          args: Prisma.PractitionerScheduleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PractitionerScheduleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PractitionerSchedulePayload>[]
        }
        delete: {
          args: Prisma.PractitionerScheduleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PractitionerSchedulePayload>
        }
        update: {
          args: Prisma.PractitionerScheduleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PractitionerSchedulePayload>
        }
        deleteMany: {
          args: Prisma.PractitionerScheduleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PractitionerScheduleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PractitionerScheduleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PractitionerSchedulePayload>[]
        }
        upsert: {
          args: Prisma.PractitionerScheduleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PractitionerSchedulePayload>
        }
        aggregate: {
          args: Prisma.PractitionerScheduleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePractitionerSchedule>
        }
        groupBy: {
          args: Prisma.PractitionerScheduleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PractitionerScheduleGroupByOutputType>[]
        }
        count: {
          args: Prisma.PractitionerScheduleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PractitionerScheduleCountAggregateOutputType> | number
        }
      }
    }
    ScheduleException: {
      payload: Prisma.$ScheduleExceptionPayload<ExtArgs>
      fields: Prisma.ScheduleExceptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ScheduleExceptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleExceptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ScheduleExceptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleExceptionPayload>
        }
        findFirst: {
          args: Prisma.ScheduleExceptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleExceptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ScheduleExceptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleExceptionPayload>
        }
        findMany: {
          args: Prisma.ScheduleExceptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleExceptionPayload>[]
        }
        create: {
          args: Prisma.ScheduleExceptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleExceptionPayload>
        }
        createMany: {
          args: Prisma.ScheduleExceptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ScheduleExceptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleExceptionPayload>[]
        }
        delete: {
          args: Prisma.ScheduleExceptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleExceptionPayload>
        }
        update: {
          args: Prisma.ScheduleExceptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleExceptionPayload>
        }
        deleteMany: {
          args: Prisma.ScheduleExceptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ScheduleExceptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ScheduleExceptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleExceptionPayload>[]
        }
        upsert: {
          args: Prisma.ScheduleExceptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleExceptionPayload>
        }
        aggregate: {
          args: Prisma.ScheduleExceptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateScheduleException>
        }
        groupBy: {
          args: Prisma.ScheduleExceptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScheduleExceptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.ScheduleExceptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScheduleExceptionCountAggregateOutputType> | number
        }
      }
    }
    NzaCode: {
      payload: Prisma.$NzaCodePayload<ExtArgs>
      fields: Prisma.NzaCodeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NzaCodeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NzaCodePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NzaCodeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NzaCodePayload>
        }
        findFirst: {
          args: Prisma.NzaCodeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NzaCodePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NzaCodeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NzaCodePayload>
        }
        findMany: {
          args: Prisma.NzaCodeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NzaCodePayload>[]
        }
        create: {
          args: Prisma.NzaCodeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NzaCodePayload>
        }
        createMany: {
          args: Prisma.NzaCodeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NzaCodeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NzaCodePayload>[]
        }
        delete: {
          args: Prisma.NzaCodeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NzaCodePayload>
        }
        update: {
          args: Prisma.NzaCodeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NzaCodePayload>
        }
        deleteMany: {
          args: Prisma.NzaCodeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NzaCodeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NzaCodeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NzaCodePayload>[]
        }
        upsert: {
          args: Prisma.NzaCodeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NzaCodePayload>
        }
        aggregate: {
          args: Prisma.NzaCodeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNzaCode>
        }
        groupBy: {
          args: Prisma.NzaCodeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NzaCodeGroupByOutputType>[]
        }
        count: {
          args: Prisma.NzaCodeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NzaCodeCountAggregateOutputType> | number
        }
      }
    }
    Invoice: {
      payload: Prisma.$InvoicePayload<ExtArgs>
      fields: Prisma.InvoiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        findFirst: {
          args: Prisma.InvoiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        findMany: {
          args: Prisma.InvoiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        create: {
          args: Prisma.InvoiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        createMany: {
          args: Prisma.InvoiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        delete: {
          args: Prisma.InvoiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        update: {
          args: Prisma.InvoiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        deleteMany: {
          args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        upsert: {
          args: Prisma.InvoiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        aggregate: {
          args: Prisma.InvoiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvoice>
        }
        groupBy: {
          args: Prisma.InvoiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvoiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceCountAggregateOutputType> | number
        }
      }
    }
    InvoiceLine: {
      payload: Prisma.$InvoiceLinePayload<ExtArgs>
      fields: Prisma.InvoiceLineFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvoiceLineFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceLinePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvoiceLineFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
        }
        findFirst: {
          args: Prisma.InvoiceLineFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceLinePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvoiceLineFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
        }
        findMany: {
          args: Prisma.InvoiceLineFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
        }
        create: {
          args: Prisma.InvoiceLineCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
        }
        createMany: {
          args: Prisma.InvoiceLineCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvoiceLineCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
        }
        delete: {
          args: Prisma.InvoiceLineDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
        }
        update: {
          args: Prisma.InvoiceLineUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
        }
        deleteMany: {
          args: Prisma.InvoiceLineDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvoiceLineUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvoiceLineUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
        }
        upsert: {
          args: Prisma.InvoiceLineUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
        }
        aggregate: {
          args: Prisma.InvoiceLineAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvoiceLine>
        }
        groupBy: {
          args: Prisma.InvoiceLineGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceLineGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvoiceLineCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceLineCountAggregateOutputType> | number
        }
      }
    }
    Payment: {
      payload: Prisma.$PaymentPayload<ExtArgs>
      fields: Prisma.PaymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        findFirst: {
          args: Prisma.PaymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        findMany: {
          args: Prisma.PaymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[]
        }
        create: {
          args: Prisma.PaymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        createMany: {
          args: Prisma.PaymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[]
        }
        delete: {
          args: Prisma.PaymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        update: {
          args: Prisma.PaymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        deleteMany: {
          args: Prisma.PaymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[]
        }
        upsert: {
          args: Prisma.PaymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        aggregate: {
          args: Prisma.PaymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayment>
        }
        groupBy: {
          args: Prisma.PaymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentCountAggregateOutputType> | number
        }
      }
    }
    InsuranceClaim: {
      payload: Prisma.$InsuranceClaimPayload<ExtArgs>
      fields: Prisma.InsuranceClaimFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InsuranceClaimFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceClaimPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InsuranceClaimFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>
        }
        findFirst: {
          args: Prisma.InsuranceClaimFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceClaimPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InsuranceClaimFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>
        }
        findMany: {
          args: Prisma.InsuranceClaimFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>[]
        }
        create: {
          args: Prisma.InsuranceClaimCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>
        }
        createMany: {
          args: Prisma.InsuranceClaimCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InsuranceClaimCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>[]
        }
        delete: {
          args: Prisma.InsuranceClaimDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>
        }
        update: {
          args: Prisma.InsuranceClaimUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>
        }
        deleteMany: {
          args: Prisma.InsuranceClaimDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InsuranceClaimUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InsuranceClaimUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>[]
        }
        upsert: {
          args: Prisma.InsuranceClaimUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>
        }
        aggregate: {
          args: Prisma.InsuranceClaimAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInsuranceClaim>
        }
        groupBy: {
          args: Prisma.InsuranceClaimGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InsuranceClaimGroupByOutputType>[]
        }
        count: {
          args: Prisma.InsuranceClaimCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InsuranceClaimCountAggregateOutputType> | number
        }
      }
    }
    ConsentTemplate: {
      payload: Prisma.$ConsentTemplatePayload<ExtArgs>
      fields: Prisma.ConsentTemplateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConsentTemplateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentTemplatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConsentTemplateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentTemplatePayload>
        }
        findFirst: {
          args: Prisma.ConsentTemplateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentTemplatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConsentTemplateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentTemplatePayload>
        }
        findMany: {
          args: Prisma.ConsentTemplateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentTemplatePayload>[]
        }
        create: {
          args: Prisma.ConsentTemplateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentTemplatePayload>
        }
        createMany: {
          args: Prisma.ConsentTemplateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConsentTemplateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentTemplatePayload>[]
        }
        delete: {
          args: Prisma.ConsentTemplateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentTemplatePayload>
        }
        update: {
          args: Prisma.ConsentTemplateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentTemplatePayload>
        }
        deleteMany: {
          args: Prisma.ConsentTemplateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConsentTemplateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConsentTemplateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentTemplatePayload>[]
        }
        upsert: {
          args: Prisma.ConsentTemplateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentTemplatePayload>
        }
        aggregate: {
          args: Prisma.ConsentTemplateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConsentTemplate>
        }
        groupBy: {
          args: Prisma.ConsentTemplateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConsentTemplateGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConsentTemplateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConsentTemplateCountAggregateOutputType> | number
        }
      }
    }
    ConsentForm: {
      payload: Prisma.$ConsentFormPayload<ExtArgs>
      fields: Prisma.ConsentFormFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConsentFormFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentFormPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConsentFormFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentFormPayload>
        }
        findFirst: {
          args: Prisma.ConsentFormFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentFormPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConsentFormFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentFormPayload>
        }
        findMany: {
          args: Prisma.ConsentFormFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentFormPayload>[]
        }
        create: {
          args: Prisma.ConsentFormCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentFormPayload>
        }
        createMany: {
          args: Prisma.ConsentFormCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConsentFormCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentFormPayload>[]
        }
        delete: {
          args: Prisma.ConsentFormDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentFormPayload>
        }
        update: {
          args: Prisma.ConsentFormUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentFormPayload>
        }
        deleteMany: {
          args: Prisma.ConsentFormDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConsentFormUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConsentFormUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentFormPayload>[]
        }
        upsert: {
          args: Prisma.ConsentFormUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsentFormPayload>
        }
        aggregate: {
          args: Prisma.ConsentFormAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConsentForm>
        }
        groupBy: {
          args: Prisma.ConsentFormGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConsentFormGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConsentFormCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConsentFormCountAggregateOutputType> | number
        }
      }
    }
    Document: {
      payload: Prisma.$DocumentPayload<ExtArgs>
      fields: Prisma.DocumentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        findFirst: {
          args: Prisma.DocumentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        findMany: {
          args: Prisma.DocumentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>[]
        }
        create: {
          args: Prisma.DocumentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        createMany: {
          args: Prisma.DocumentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>[]
        }
        delete: {
          args: Prisma.DocumentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        update: {
          args: Prisma.DocumentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        deleteMany: {
          args: Prisma.DocumentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>[]
        }
        upsert: {
          args: Prisma.DocumentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        aggregate: {
          args: Prisma.DocumentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocument>
        }
        groupBy: {
          args: Prisma.DocumentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentCountAggregateOutputType> | number
        }
      }
    }
    AuditLog: {
      payload: Prisma.$AuditLogPayload<ExtArgs>
      fields: Prisma.AuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findFirst: {
          args: Prisma.AuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findMany: {
          args: Prisma.AuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        create: {
          args: Prisma.AuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        createMany: {
          args: Prisma.AuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        delete: {
          args: Prisma.AuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        update: {
          args: Prisma.AuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        deleteMany: {
          args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        upsert: {
          args: Prisma.AuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        aggregate: {
          args: Prisma.AuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAuditLog>
        }
        groupBy: {
          args: Prisma.AuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.AuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogCountAggregateOutputType> | number
        }
      }
    }
    Notification: {
      payload: Prisma.$NotificationPayload<ExtArgs>
      fields: Prisma.NotificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findFirst: {
          args: Prisma.NotificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findMany: {
          args: Prisma.NotificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        create: {
          args: Prisma.NotificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        createMany: {
          args: Prisma.NotificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        delete: {
          args: Prisma.NotificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        update: {
          args: Prisma.NotificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        deleteMany: {
          args: Prisma.NotificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        upsert: {
          args: Prisma.NotificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        aggregate: {
          args: Prisma.NotificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotification>
        }
        groupBy: {
          args: Prisma.NotificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationCountAggregateOutputType> | number
        }
      }
    }
    Credential: {
      payload: Prisma.$CredentialPayload<ExtArgs>
      fields: Prisma.CredentialFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CredentialFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CredentialPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CredentialFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CredentialPayload>
        }
        findFirst: {
          args: Prisma.CredentialFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CredentialPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CredentialFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CredentialPayload>
        }
        findMany: {
          args: Prisma.CredentialFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CredentialPayload>[]
        }
        create: {
          args: Prisma.CredentialCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CredentialPayload>
        }
        createMany: {
          args: Prisma.CredentialCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CredentialCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CredentialPayload>[]
        }
        delete: {
          args: Prisma.CredentialDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CredentialPayload>
        }
        update: {
          args: Prisma.CredentialUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CredentialPayload>
        }
        deleteMany: {
          args: Prisma.CredentialDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CredentialUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CredentialUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CredentialPayload>[]
        }
        upsert: {
          args: Prisma.CredentialUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CredentialPayload>
        }
        aggregate: {
          args: Prisma.CredentialAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCredential>
        }
        groupBy: {
          args: Prisma.CredentialGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CredentialGroupByOutputType>[]
        }
        count: {
          args: Prisma.CredentialCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CredentialCountAggregateOutputType> | number
        }
      }
    }
    Prescription: {
      payload: Prisma.$PrescriptionPayload<ExtArgs>
      fields: Prisma.PrescriptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PrescriptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PrescriptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>
        }
        findFirst: {
          args: Prisma.PrescriptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PrescriptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>
        }
        findMany: {
          args: Prisma.PrescriptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
        }
        create: {
          args: Prisma.PrescriptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>
        }
        createMany: {
          args: Prisma.PrescriptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PrescriptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
        }
        delete: {
          args: Prisma.PrescriptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>
        }
        update: {
          args: Prisma.PrescriptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>
        }
        deleteMany: {
          args: Prisma.PrescriptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PrescriptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PrescriptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
        }
        upsert: {
          args: Prisma.PrescriptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>
        }
        aggregate: {
          args: Prisma.PrescriptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePrescription>
        }
        groupBy: {
          args: Prisma.PrescriptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PrescriptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.PrescriptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PrescriptionCountAggregateOutputType> | number
        }
      }
    }
    PeriodontalChart: {
      payload: Prisma.$PeriodontalChartPayload<ExtArgs>
      fields: Prisma.PeriodontalChartFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PeriodontalChartFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodontalChartPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PeriodontalChartFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodontalChartPayload>
        }
        findFirst: {
          args: Prisma.PeriodontalChartFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodontalChartPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PeriodontalChartFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodontalChartPayload>
        }
        findMany: {
          args: Prisma.PeriodontalChartFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodontalChartPayload>[]
        }
        create: {
          args: Prisma.PeriodontalChartCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodontalChartPayload>
        }
        createMany: {
          args: Prisma.PeriodontalChartCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PeriodontalChartCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodontalChartPayload>[]
        }
        delete: {
          args: Prisma.PeriodontalChartDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodontalChartPayload>
        }
        update: {
          args: Prisma.PeriodontalChartUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodontalChartPayload>
        }
        deleteMany: {
          args: Prisma.PeriodontalChartDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PeriodontalChartUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PeriodontalChartUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodontalChartPayload>[]
        }
        upsert: {
          args: Prisma.PeriodontalChartUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodontalChartPayload>
        }
        aggregate: {
          args: Prisma.PeriodontalChartAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePeriodontalChart>
        }
        groupBy: {
          args: Prisma.PeriodontalChartGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PeriodontalChartGroupByOutputType>[]
        }
        count: {
          args: Prisma.PeriodontalChartCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PeriodontalChartCountAggregateOutputType> | number
        }
      }
    }
    PatientImage: {
      payload: Prisma.$PatientImagePayload<ExtArgs>
      fields: Prisma.PatientImageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PatientImageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientImagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PatientImageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientImagePayload>
        }
        findFirst: {
          args: Prisma.PatientImageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientImagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PatientImageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientImagePayload>
        }
        findMany: {
          args: Prisma.PatientImageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientImagePayload>[]
        }
        create: {
          args: Prisma.PatientImageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientImagePayload>
        }
        createMany: {
          args: Prisma.PatientImageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PatientImageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientImagePayload>[]
        }
        delete: {
          args: Prisma.PatientImageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientImagePayload>
        }
        update: {
          args: Prisma.PatientImageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientImagePayload>
        }
        deleteMany: {
          args: Prisma.PatientImageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PatientImageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PatientImageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientImagePayload>[]
        }
        upsert: {
          args: Prisma.PatientImageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientImagePayload>
        }
        aggregate: {
          args: Prisma.PatientImageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePatientImage>
        }
        groupBy: {
          args: Prisma.PatientImageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PatientImageGroupByOutputType>[]
        }
        count: {
          args: Prisma.PatientImageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PatientImageCountAggregateOutputType> | number
        }
      }
    }
    Anamnesis: {
      payload: Prisma.$AnamnesisPayload<ExtArgs>
      fields: Prisma.AnamnesisFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AnamnesisFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnamnesisPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AnamnesisFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnamnesisPayload>
        }
        findFirst: {
          args: Prisma.AnamnesisFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnamnesisPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AnamnesisFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnamnesisPayload>
        }
        findMany: {
          args: Prisma.AnamnesisFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnamnesisPayload>[]
        }
        create: {
          args: Prisma.AnamnesisCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnamnesisPayload>
        }
        createMany: {
          args: Prisma.AnamnesisCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AnamnesisCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnamnesisPayload>[]
        }
        delete: {
          args: Prisma.AnamnesisDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnamnesisPayload>
        }
        update: {
          args: Prisma.AnamnesisUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnamnesisPayload>
        }
        deleteMany: {
          args: Prisma.AnamnesisDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AnamnesisUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AnamnesisUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnamnesisPayload>[]
        }
        upsert: {
          args: Prisma.AnamnesisUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnamnesisPayload>
        }
        aggregate: {
          args: Prisma.AnamnesisAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAnamnesis>
        }
        groupBy: {
          args: Prisma.AnamnesisGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AnamnesisGroupByOutputType>[]
        }
        count: {
          args: Prisma.AnamnesisCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AnamnesisCountAggregateOutputType> | number
        }
      }
    }
    Message: {
      payload: Prisma.$MessagePayload<ExtArgs>
      fields: Prisma.MessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        findFirst: {
          args: Prisma.MessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        findMany: {
          args: Prisma.MessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]
        }
        create: {
          args: Prisma.MessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        createMany: {
          args: Prisma.MessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]
        }
        delete: {
          args: Prisma.MessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        update: {
          args: Prisma.MessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        deleteMany: {
          args: Prisma.MessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]
        }
        upsert: {
          args: Prisma.MessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        aggregate: {
          args: Prisma.MessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMessage>
        }
        groupBy: {
          args: Prisma.MessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.MessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageCountAggregateOutputType> | number
        }
      }
    }
    Referral: {
      payload: Prisma.$ReferralPayload<ExtArgs>
      fields: Prisma.ReferralFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReferralFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferralPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReferralFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferralPayload>
        }
        findFirst: {
          args: Prisma.ReferralFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferralPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReferralFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferralPayload>
        }
        findMany: {
          args: Prisma.ReferralFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferralPayload>[]
        }
        create: {
          args: Prisma.ReferralCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferralPayload>
        }
        createMany: {
          args: Prisma.ReferralCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReferralCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferralPayload>[]
        }
        delete: {
          args: Prisma.ReferralDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferralPayload>
        }
        update: {
          args: Prisma.ReferralUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferralPayload>
        }
        deleteMany: {
          args: Prisma.ReferralDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReferralUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReferralUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferralPayload>[]
        }
        upsert: {
          args: Prisma.ReferralUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferralPayload>
        }
        aggregate: {
          args: Prisma.ReferralAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReferral>
        }
        groupBy: {
          args: Prisma.ReferralGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReferralGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReferralCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReferralCountAggregateOutputType> | number
        }
      }
    }
    Complaint: {
      payload: Prisma.$ComplaintPayload<ExtArgs>
      fields: Prisma.ComplaintFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ComplaintFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ComplaintPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ComplaintFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ComplaintPayload>
        }
        findFirst: {
          args: Prisma.ComplaintFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ComplaintPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ComplaintFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ComplaintPayload>
        }
        findMany: {
          args: Prisma.ComplaintFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ComplaintPayload>[]
        }
        create: {
          args: Prisma.ComplaintCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ComplaintPayload>
        }
        createMany: {
          args: Prisma.ComplaintCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ComplaintCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ComplaintPayload>[]
        }
        delete: {
          args: Prisma.ComplaintDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ComplaintPayload>
        }
        update: {
          args: Prisma.ComplaintUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ComplaintPayload>
        }
        deleteMany: {
          args: Prisma.ComplaintDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ComplaintUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ComplaintUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ComplaintPayload>[]
        }
        upsert: {
          args: Prisma.ComplaintUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ComplaintPayload>
        }
        aggregate: {
          args: Prisma.ComplaintAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateComplaint>
        }
        groupBy: {
          args: Prisma.ComplaintGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ComplaintGroupByOutputType>[]
        }
        count: {
          args: Prisma.ComplaintCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ComplaintCountAggregateOutputType> | number
        }
      }
    }
    EmailThread: {
      payload: Prisma.$EmailThreadPayload<ExtArgs>
      fields: Prisma.EmailThreadFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EmailThreadFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailThreadPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EmailThreadFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailThreadPayload>
        }
        findFirst: {
          args: Prisma.EmailThreadFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailThreadPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EmailThreadFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailThreadPayload>
        }
        findMany: {
          args: Prisma.EmailThreadFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailThreadPayload>[]
        }
        create: {
          args: Prisma.EmailThreadCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailThreadPayload>
        }
        createMany: {
          args: Prisma.EmailThreadCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EmailThreadCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailThreadPayload>[]
        }
        delete: {
          args: Prisma.EmailThreadDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailThreadPayload>
        }
        update: {
          args: Prisma.EmailThreadUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailThreadPayload>
        }
        deleteMany: {
          args: Prisma.EmailThreadDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EmailThreadUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EmailThreadUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailThreadPayload>[]
        }
        upsert: {
          args: Prisma.EmailThreadUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailThreadPayload>
        }
        aggregate: {
          args: Prisma.EmailThreadAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmailThread>
        }
        groupBy: {
          args: Prisma.EmailThreadGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailThreadGroupByOutputType>[]
        }
        count: {
          args: Prisma.EmailThreadCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailThreadCountAggregateOutputType> | number
        }
      }
    }
    EmailMessage: {
      payload: Prisma.$EmailMessagePayload<ExtArgs>
      fields: Prisma.EmailMessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EmailMessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailMessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EmailMessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailMessagePayload>
        }
        findFirst: {
          args: Prisma.EmailMessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailMessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EmailMessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailMessagePayload>
        }
        findMany: {
          args: Prisma.EmailMessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailMessagePayload>[]
        }
        create: {
          args: Prisma.EmailMessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailMessagePayload>
        }
        createMany: {
          args: Prisma.EmailMessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EmailMessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailMessagePayload>[]
        }
        delete: {
          args: Prisma.EmailMessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailMessagePayload>
        }
        update: {
          args: Prisma.EmailMessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailMessagePayload>
        }
        deleteMany: {
          args: Prisma.EmailMessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EmailMessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EmailMessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailMessagePayload>[]
        }
        upsert: {
          args: Prisma.EmailMessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailMessagePayload>
        }
        aggregate: {
          args: Prisma.EmailMessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmailMessage>
        }
        groupBy: {
          args: Prisma.EmailMessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailMessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.EmailMessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailMessageCountAggregateOutputType> | number
        }
      }
    }
    WhatsAppConversation: {
      payload: Prisma.$WhatsAppConversationPayload<ExtArgs>
      fields: Prisma.WhatsAppConversationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WhatsAppConversationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WhatsAppConversationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload>
        }
        findFirst: {
          args: Prisma.WhatsAppConversationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WhatsAppConversationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload>
        }
        findMany: {
          args: Prisma.WhatsAppConversationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload>[]
        }
        create: {
          args: Prisma.WhatsAppConversationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload>
        }
        createMany: {
          args: Prisma.WhatsAppConversationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WhatsAppConversationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload>[]
        }
        delete: {
          args: Prisma.WhatsAppConversationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload>
        }
        update: {
          args: Prisma.WhatsAppConversationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload>
        }
        deleteMany: {
          args: Prisma.WhatsAppConversationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WhatsAppConversationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WhatsAppConversationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload>[]
        }
        upsert: {
          args: Prisma.WhatsAppConversationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload>
        }
        aggregate: {
          args: Prisma.WhatsAppConversationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWhatsAppConversation>
        }
        groupBy: {
          args: Prisma.WhatsAppConversationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WhatsAppConversationGroupByOutputType>[]
        }
        count: {
          args: Prisma.WhatsAppConversationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WhatsAppConversationCountAggregateOutputType> | number
        }
      }
    }
    WhatsAppMessage: {
      payload: Prisma.$WhatsAppMessagePayload<ExtArgs>
      fields: Prisma.WhatsAppMessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WhatsAppMessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WhatsAppMessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload>
        }
        findFirst: {
          args: Prisma.WhatsAppMessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WhatsAppMessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload>
        }
        findMany: {
          args: Prisma.WhatsAppMessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload>[]
        }
        create: {
          args: Prisma.WhatsAppMessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload>
        }
        createMany: {
          args: Prisma.WhatsAppMessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WhatsAppMessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload>[]
        }
        delete: {
          args: Prisma.WhatsAppMessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload>
        }
        update: {
          args: Prisma.WhatsAppMessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload>
        }
        deleteMany: {
          args: Prisma.WhatsAppMessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WhatsAppMessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WhatsAppMessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload>[]
        }
        upsert: {
          args: Prisma.WhatsAppMessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload>
        }
        aggregate: {
          args: Prisma.WhatsAppMessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWhatsAppMessage>
        }
        groupBy: {
          args: Prisma.WhatsAppMessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WhatsAppMessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.WhatsAppMessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WhatsAppMessageCountAggregateOutputType> | number
        }
      }
    }
    PatientCategory: {
      payload: Prisma.$PatientCategoryPayload<ExtArgs>
      fields: Prisma.PatientCategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PatientCategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientCategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PatientCategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientCategoryPayload>
        }
        findFirst: {
          args: Prisma.PatientCategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientCategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PatientCategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientCategoryPayload>
        }
        findMany: {
          args: Prisma.PatientCategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientCategoryPayload>[]
        }
        create: {
          args: Prisma.PatientCategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientCategoryPayload>
        }
        createMany: {
          args: Prisma.PatientCategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PatientCategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientCategoryPayload>[]
        }
        delete: {
          args: Prisma.PatientCategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientCategoryPayload>
        }
        update: {
          args: Prisma.PatientCategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientCategoryPayload>
        }
        deleteMany: {
          args: Prisma.PatientCategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PatientCategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PatientCategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientCategoryPayload>[]
        }
        upsert: {
          args: Prisma.PatientCategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientCategoryPayload>
        }
        aggregate: {
          args: Prisma.PatientCategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePatientCategory>
        }
        groupBy: {
          args: Prisma.PatientCategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PatientCategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.PatientCategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PatientCategoryCountAggregateOutputType> | number
        }
      }
    }
    CustomCodeCategory: {
      payload: Prisma.$CustomCodeCategoryPayload<ExtArgs>
      fields: Prisma.CustomCodeCategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomCodeCategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomCodeCategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryPayload>
        }
        findFirst: {
          args: Prisma.CustomCodeCategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomCodeCategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryPayload>
        }
        findMany: {
          args: Prisma.CustomCodeCategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryPayload>[]
        }
        create: {
          args: Prisma.CustomCodeCategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryPayload>
        }
        createMany: {
          args: Prisma.CustomCodeCategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomCodeCategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryPayload>[]
        }
        delete: {
          args: Prisma.CustomCodeCategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryPayload>
        }
        update: {
          args: Prisma.CustomCodeCategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryPayload>
        }
        deleteMany: {
          args: Prisma.CustomCodeCategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomCodeCategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomCodeCategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryPayload>[]
        }
        upsert: {
          args: Prisma.CustomCodeCategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryPayload>
        }
        aggregate: {
          args: Prisma.CustomCodeCategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomCodeCategory>
        }
        groupBy: {
          args: Prisma.CustomCodeCategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomCodeCategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomCodeCategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomCodeCategoryCountAggregateOutputType> | number
        }
      }
    }
    CustomCodeCategoryCode: {
      payload: Prisma.$CustomCodeCategoryCodePayload<ExtArgs>
      fields: Prisma.CustomCodeCategoryCodeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomCodeCategoryCodeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryCodePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomCodeCategoryCodeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryCodePayload>
        }
        findFirst: {
          args: Prisma.CustomCodeCategoryCodeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryCodePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomCodeCategoryCodeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryCodePayload>
        }
        findMany: {
          args: Prisma.CustomCodeCategoryCodeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryCodePayload>[]
        }
        create: {
          args: Prisma.CustomCodeCategoryCodeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryCodePayload>
        }
        createMany: {
          args: Prisma.CustomCodeCategoryCodeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomCodeCategoryCodeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryCodePayload>[]
        }
        delete: {
          args: Prisma.CustomCodeCategoryCodeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryCodePayload>
        }
        update: {
          args: Prisma.CustomCodeCategoryCodeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryCodePayload>
        }
        deleteMany: {
          args: Prisma.CustomCodeCategoryCodeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomCodeCategoryCodeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomCodeCategoryCodeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryCodePayload>[]
        }
        upsert: {
          args: Prisma.CustomCodeCategoryCodeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomCodeCategoryCodePayload>
        }
        aggregate: {
          args: Prisma.CustomCodeCategoryCodeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomCodeCategoryCode>
        }
        groupBy: {
          args: Prisma.CustomCodeCategoryCodeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomCodeCategoryCodeGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomCodeCategoryCodeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomCodeCategoryCodeCountAggregateOutputType> | number
        }
      }
    }
    DsdDesign: {
      payload: Prisma.$DsdDesignPayload<ExtArgs>
      fields: Prisma.DsdDesignFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DsdDesignFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DsdDesignFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignPayload>
        }
        findFirst: {
          args: Prisma.DsdDesignFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DsdDesignFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignPayload>
        }
        findMany: {
          args: Prisma.DsdDesignFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignPayload>[]
        }
        create: {
          args: Prisma.DsdDesignCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignPayload>
        }
        createMany: {
          args: Prisma.DsdDesignCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DsdDesignCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignPayload>[]
        }
        delete: {
          args: Prisma.DsdDesignDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignPayload>
        }
        update: {
          args: Prisma.DsdDesignUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignPayload>
        }
        deleteMany: {
          args: Prisma.DsdDesignDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DsdDesignUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DsdDesignUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignPayload>[]
        }
        upsert: {
          args: Prisma.DsdDesignUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignPayload>
        }
        aggregate: {
          args: Prisma.DsdDesignAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDsdDesign>
        }
        groupBy: {
          args: Prisma.DsdDesignGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DsdDesignGroupByOutputType>[]
        }
        count: {
          args: Prisma.DsdDesignCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DsdDesignCountAggregateOutputType> | number
        }
      }
    }
    DsdDesignVersion: {
      payload: Prisma.$DsdDesignVersionPayload<ExtArgs>
      fields: Prisma.DsdDesignVersionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DsdDesignVersionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignVersionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DsdDesignVersionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignVersionPayload>
        }
        findFirst: {
          args: Prisma.DsdDesignVersionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignVersionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DsdDesignVersionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignVersionPayload>
        }
        findMany: {
          args: Prisma.DsdDesignVersionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignVersionPayload>[]
        }
        create: {
          args: Prisma.DsdDesignVersionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignVersionPayload>
        }
        createMany: {
          args: Prisma.DsdDesignVersionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DsdDesignVersionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignVersionPayload>[]
        }
        delete: {
          args: Prisma.DsdDesignVersionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignVersionPayload>
        }
        update: {
          args: Prisma.DsdDesignVersionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignVersionPayload>
        }
        deleteMany: {
          args: Prisma.DsdDesignVersionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DsdDesignVersionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DsdDesignVersionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignVersionPayload>[]
        }
        upsert: {
          args: Prisma.DsdDesignVersionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DsdDesignVersionPayload>
        }
        aggregate: {
          args: Prisma.DsdDesignVersionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDsdDesignVersion>
        }
        groupBy: {
          args: Prisma.DsdDesignVersionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DsdDesignVersionGroupByOutputType>[]
        }
        count: {
          args: Prisma.DsdDesignVersionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DsdDesignVersionCountAggregateOutputType> | number
        }
      }
    }
    Conversation: {
      payload: Prisma.$ConversationPayload<ExtArgs>
      fields: Prisma.ConversationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConversationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        findFirst: {
          args: Prisma.ConversationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        findMany: {
          args: Prisma.ConversationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>[]
        }
        create: {
          args: Prisma.ConversationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        createMany: {
          args: Prisma.ConversationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>[]
        }
        delete: {
          args: Prisma.ConversationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        update: {
          args: Prisma.ConversationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        deleteMany: {
          args: Prisma.ConversationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConversationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>[]
        }
        upsert: {
          args: Prisma.ConversationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        aggregate: {
          args: Prisma.ConversationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConversation>
        }
        groupBy: {
          args: Prisma.ConversationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConversationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationCountAggregateOutputType> | number
        }
      }
    }
    ConversationMessage: {
      payload: Prisma.$ConversationMessagePayload<ExtArgs>
      fields: Prisma.ConversationMessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConversationMessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConversationMessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
        }
        findFirst: {
          args: Prisma.ConversationMessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConversationMessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
        }
        findMany: {
          args: Prisma.ConversationMessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMessagePayload>[]
        }
        create: {
          args: Prisma.ConversationMessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
        }
        createMany: {
          args: Prisma.ConversationMessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConversationMessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMessagePayload>[]
        }
        delete: {
          args: Prisma.ConversationMessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
        }
        update: {
          args: Prisma.ConversationMessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
        }
        deleteMany: {
          args: Prisma.ConversationMessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConversationMessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConversationMessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMessagePayload>[]
        }
        upsert: {
          args: Prisma.ConversationMessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
        }
        aggregate: {
          args: Prisma.ConversationMessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConversationMessage>
        }
        groupBy: {
          args: Prisma.ConversationMessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationMessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConversationMessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationMessageCountAggregateOutputType> | number
        }
      }
    }
    MessageAttachment: {
      payload: Prisma.$MessageAttachmentPayload<ExtArgs>
      fields: Prisma.MessageAttachmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MessageAttachmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageAttachmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MessageAttachmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
        }
        findFirst: {
          args: Prisma.MessageAttachmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageAttachmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MessageAttachmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
        }
        findMany: {
          args: Prisma.MessageAttachmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>[]
        }
        create: {
          args: Prisma.MessageAttachmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
        }
        createMany: {
          args: Prisma.MessageAttachmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MessageAttachmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>[]
        }
        delete: {
          args: Prisma.MessageAttachmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
        }
        update: {
          args: Prisma.MessageAttachmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
        }
        deleteMany: {
          args: Prisma.MessageAttachmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MessageAttachmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MessageAttachmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>[]
        }
        upsert: {
          args: Prisma.MessageAttachmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
        }
        aggregate: {
          args: Prisma.MessageAttachmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMessageAttachment>
        }
        groupBy: {
          args: Prisma.MessageAttachmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageAttachmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.MessageAttachmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageAttachmentCountAggregateOutputType> | number
        }
      }
    }
    DentistTask: {
      payload: Prisma.$DentistTaskPayload<ExtArgs>
      fields: Prisma.DentistTaskFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DentistTaskFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DentistTaskPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DentistTaskFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DentistTaskPayload>
        }
        findFirst: {
          args: Prisma.DentistTaskFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DentistTaskPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DentistTaskFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DentistTaskPayload>
        }
        findMany: {
          args: Prisma.DentistTaskFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DentistTaskPayload>[]
        }
        create: {
          args: Prisma.DentistTaskCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DentistTaskPayload>
        }
        createMany: {
          args: Prisma.DentistTaskCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DentistTaskCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DentistTaskPayload>[]
        }
        delete: {
          args: Prisma.DentistTaskDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DentistTaskPayload>
        }
        update: {
          args: Prisma.DentistTaskUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DentistTaskPayload>
        }
        deleteMany: {
          args: Prisma.DentistTaskDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DentistTaskUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DentistTaskUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DentistTaskPayload>[]
        }
        upsert: {
          args: Prisma.DentistTaskUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DentistTaskPayload>
        }
        aggregate: {
          args: Prisma.DentistTaskAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDentistTask>
        }
        groupBy: {
          args: Prisma.DentistTaskGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DentistTaskGroupByOutputType>[]
        }
        count: {
          args: Prisma.DentistTaskCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DentistTaskCountAggregateOutputType> | number
        }
      }
    }
    AiChatSession: {
      payload: Prisma.$AiChatSessionPayload<ExtArgs>
      fields: Prisma.AiChatSessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiChatSessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatSessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiChatSessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatSessionPayload>
        }
        findFirst: {
          args: Prisma.AiChatSessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatSessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiChatSessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatSessionPayload>
        }
        findMany: {
          args: Prisma.AiChatSessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatSessionPayload>[]
        }
        create: {
          args: Prisma.AiChatSessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatSessionPayload>
        }
        createMany: {
          args: Prisma.AiChatSessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiChatSessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatSessionPayload>[]
        }
        delete: {
          args: Prisma.AiChatSessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatSessionPayload>
        }
        update: {
          args: Prisma.AiChatSessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatSessionPayload>
        }
        deleteMany: {
          args: Prisma.AiChatSessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiChatSessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiChatSessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatSessionPayload>[]
        }
        upsert: {
          args: Prisma.AiChatSessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatSessionPayload>
        }
        aggregate: {
          args: Prisma.AiChatSessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiChatSession>
        }
        groupBy: {
          args: Prisma.AiChatSessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiChatSessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiChatSessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiChatSessionCountAggregateOutputType> | number
        }
      }
    }
    AiChatMessage: {
      payload: Prisma.$AiChatMessagePayload<ExtArgs>
      fields: Prisma.AiChatMessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiChatMessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatMessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiChatMessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatMessagePayload>
        }
        findFirst: {
          args: Prisma.AiChatMessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatMessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiChatMessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatMessagePayload>
        }
        findMany: {
          args: Prisma.AiChatMessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatMessagePayload>[]
        }
        create: {
          args: Prisma.AiChatMessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatMessagePayload>
        }
        createMany: {
          args: Prisma.AiChatMessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiChatMessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatMessagePayload>[]
        }
        delete: {
          args: Prisma.AiChatMessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatMessagePayload>
        }
        update: {
          args: Prisma.AiChatMessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatMessagePayload>
        }
        deleteMany: {
          args: Prisma.AiChatMessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiChatMessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiChatMessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatMessagePayload>[]
        }
        upsert: {
          args: Prisma.AiChatMessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatMessagePayload>
        }
        aggregate: {
          args: Prisma.AiChatMessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiChatMessage>
        }
        groupBy: {
          args: Prisma.AiChatMessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiChatMessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiChatMessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiChatMessageCountAggregateOutputType> | number
        }
      }
    }
    PatientNudge: {
      payload: Prisma.$PatientNudgePayload<ExtArgs>
      fields: Prisma.PatientNudgeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PatientNudgeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientNudgePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PatientNudgeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientNudgePayload>
        }
        findFirst: {
          args: Prisma.PatientNudgeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientNudgePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PatientNudgeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientNudgePayload>
        }
        findMany: {
          args: Prisma.PatientNudgeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientNudgePayload>[]
        }
        create: {
          args: Prisma.PatientNudgeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientNudgePayload>
        }
        createMany: {
          args: Prisma.PatientNudgeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PatientNudgeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientNudgePayload>[]
        }
        delete: {
          args: Prisma.PatientNudgeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientNudgePayload>
        }
        update: {
          args: Prisma.PatientNudgeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientNudgePayload>
        }
        deleteMany: {
          args: Prisma.PatientNudgeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PatientNudgeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PatientNudgeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientNudgePayload>[]
        }
        upsert: {
          args: Prisma.PatientNudgeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientNudgePayload>
        }
        aggregate: {
          args: Prisma.PatientNudgeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePatientNudge>
        }
        groupBy: {
          args: Prisma.PatientNudgeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PatientNudgeGroupByOutputType>[]
        }
        count: {
          args: Prisma.PatientNudgeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PatientNudgeCountAggregateOutputType> | number
        }
      }
    }
    StaffChat: {
      payload: Prisma.$StaffChatPayload<ExtArgs>
      fields: Prisma.StaffChatFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StaffChatFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StaffChatFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatPayload>
        }
        findFirst: {
          args: Prisma.StaffChatFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StaffChatFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatPayload>
        }
        findMany: {
          args: Prisma.StaffChatFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatPayload>[]
        }
        create: {
          args: Prisma.StaffChatCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatPayload>
        }
        createMany: {
          args: Prisma.StaffChatCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StaffChatCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatPayload>[]
        }
        delete: {
          args: Prisma.StaffChatDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatPayload>
        }
        update: {
          args: Prisma.StaffChatUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatPayload>
        }
        deleteMany: {
          args: Prisma.StaffChatDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StaffChatUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StaffChatUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatPayload>[]
        }
        upsert: {
          args: Prisma.StaffChatUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatPayload>
        }
        aggregate: {
          args: Prisma.StaffChatAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStaffChat>
        }
        groupBy: {
          args: Prisma.StaffChatGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StaffChatGroupByOutputType>[]
        }
        count: {
          args: Prisma.StaffChatCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StaffChatCountAggregateOutputType> | number
        }
      }
    }
    StaffChatMember: {
      payload: Prisma.$StaffChatMemberPayload<ExtArgs>
      fields: Prisma.StaffChatMemberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StaffChatMemberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMemberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StaffChatMemberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMemberPayload>
        }
        findFirst: {
          args: Prisma.StaffChatMemberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMemberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StaffChatMemberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMemberPayload>
        }
        findMany: {
          args: Prisma.StaffChatMemberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMemberPayload>[]
        }
        create: {
          args: Prisma.StaffChatMemberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMemberPayload>
        }
        createMany: {
          args: Prisma.StaffChatMemberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StaffChatMemberCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMemberPayload>[]
        }
        delete: {
          args: Prisma.StaffChatMemberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMemberPayload>
        }
        update: {
          args: Prisma.StaffChatMemberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMemberPayload>
        }
        deleteMany: {
          args: Prisma.StaffChatMemberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StaffChatMemberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StaffChatMemberUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMemberPayload>[]
        }
        upsert: {
          args: Prisma.StaffChatMemberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMemberPayload>
        }
        aggregate: {
          args: Prisma.StaffChatMemberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStaffChatMember>
        }
        groupBy: {
          args: Prisma.StaffChatMemberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StaffChatMemberGroupByOutputType>[]
        }
        count: {
          args: Prisma.StaffChatMemberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StaffChatMemberCountAggregateOutputType> | number
        }
      }
    }
    StaffChatMessage: {
      payload: Prisma.$StaffChatMessagePayload<ExtArgs>
      fields: Prisma.StaffChatMessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StaffChatMessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StaffChatMessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMessagePayload>
        }
        findFirst: {
          args: Prisma.StaffChatMessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StaffChatMessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMessagePayload>
        }
        findMany: {
          args: Prisma.StaffChatMessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMessagePayload>[]
        }
        create: {
          args: Prisma.StaffChatMessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMessagePayload>
        }
        createMany: {
          args: Prisma.StaffChatMessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StaffChatMessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMessagePayload>[]
        }
        delete: {
          args: Prisma.StaffChatMessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMessagePayload>
        }
        update: {
          args: Prisma.StaffChatMessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMessagePayload>
        }
        deleteMany: {
          args: Prisma.StaffChatMessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StaffChatMessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StaffChatMessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMessagePayload>[]
        }
        upsert: {
          args: Prisma.StaffChatMessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffChatMessagePayload>
        }
        aggregate: {
          args: Prisma.StaffChatMessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStaffChatMessage>
        }
        groupBy: {
          args: Prisma.StaffChatMessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StaffChatMessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.StaffChatMessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StaffChatMessageCountAggregateOutputType> | number
        }
      }
    }
    PerioSession: {
      payload: Prisma.$PerioSessionPayload<ExtArgs>
      fields: Prisma.PerioSessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PerioSessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PerioSessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSessionPayload>
        }
        findFirst: {
          args: Prisma.PerioSessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PerioSessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSessionPayload>
        }
        findMany: {
          args: Prisma.PerioSessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSessionPayload>[]
        }
        create: {
          args: Prisma.PerioSessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSessionPayload>
        }
        createMany: {
          args: Prisma.PerioSessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PerioSessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSessionPayload>[]
        }
        delete: {
          args: Prisma.PerioSessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSessionPayload>
        }
        update: {
          args: Prisma.PerioSessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSessionPayload>
        }
        deleteMany: {
          args: Prisma.PerioSessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PerioSessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PerioSessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSessionPayload>[]
        }
        upsert: {
          args: Prisma.PerioSessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSessionPayload>
        }
        aggregate: {
          args: Prisma.PerioSessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePerioSession>
        }
        groupBy: {
          args: Prisma.PerioSessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PerioSessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.PerioSessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PerioSessionCountAggregateOutputType> | number
        }
      }
    }
    PerioSite: {
      payload: Prisma.$PerioSitePayload<ExtArgs>
      fields: Prisma.PerioSiteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PerioSiteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSitePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PerioSiteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSitePayload>
        }
        findFirst: {
          args: Prisma.PerioSiteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSitePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PerioSiteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSitePayload>
        }
        findMany: {
          args: Prisma.PerioSiteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSitePayload>[]
        }
        create: {
          args: Prisma.PerioSiteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSitePayload>
        }
        createMany: {
          args: Prisma.PerioSiteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PerioSiteCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSitePayload>[]
        }
        delete: {
          args: Prisma.PerioSiteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSitePayload>
        }
        update: {
          args: Prisma.PerioSiteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSitePayload>
        }
        deleteMany: {
          args: Prisma.PerioSiteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PerioSiteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PerioSiteUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSitePayload>[]
        }
        upsert: {
          args: Prisma.PerioSiteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioSitePayload>
        }
        aggregate: {
          args: Prisma.PerioSiteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePerioSite>
        }
        groupBy: {
          args: Prisma.PerioSiteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PerioSiteGroupByOutputType>[]
        }
        count: {
          args: Prisma.PerioSiteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PerioSiteCountAggregateOutputType> | number
        }
      }
    }
    PerioProtocol: {
      payload: Prisma.$PerioProtocolPayload<ExtArgs>
      fields: Prisma.PerioProtocolFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PerioProtocolFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioProtocolPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PerioProtocolFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioProtocolPayload>
        }
        findFirst: {
          args: Prisma.PerioProtocolFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioProtocolPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PerioProtocolFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioProtocolPayload>
        }
        findMany: {
          args: Prisma.PerioProtocolFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioProtocolPayload>[]
        }
        create: {
          args: Prisma.PerioProtocolCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioProtocolPayload>
        }
        createMany: {
          args: Prisma.PerioProtocolCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PerioProtocolCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioProtocolPayload>[]
        }
        delete: {
          args: Prisma.PerioProtocolDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioProtocolPayload>
        }
        update: {
          args: Prisma.PerioProtocolUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioProtocolPayload>
        }
        deleteMany: {
          args: Prisma.PerioProtocolDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PerioProtocolUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PerioProtocolUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioProtocolPayload>[]
        }
        upsert: {
          args: Prisma.PerioProtocolUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerioProtocolPayload>
        }
        aggregate: {
          args: Prisma.PerioProtocolAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePerioProtocol>
        }
        groupBy: {
          args: Prisma.PerioProtocolGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PerioProtocolGroupByOutputType>[]
        }
        count: {
          args: Prisma.PerioProtocolCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PerioProtocolCountAggregateOutputType> | number
        }
      }
    }
    RecallSchedule: {
      payload: Prisma.$RecallSchedulePayload<ExtArgs>
      fields: Prisma.RecallScheduleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RecallScheduleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecallSchedulePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RecallScheduleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecallSchedulePayload>
        }
        findFirst: {
          args: Prisma.RecallScheduleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecallSchedulePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RecallScheduleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecallSchedulePayload>
        }
        findMany: {
          args: Prisma.RecallScheduleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecallSchedulePayload>[]
        }
        create: {
          args: Prisma.RecallScheduleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecallSchedulePayload>
        }
        createMany: {
          args: Prisma.RecallScheduleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RecallScheduleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecallSchedulePayload>[]
        }
        delete: {
          args: Prisma.RecallScheduleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecallSchedulePayload>
        }
        update: {
          args: Prisma.RecallScheduleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecallSchedulePayload>
        }
        deleteMany: {
          args: Prisma.RecallScheduleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RecallScheduleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RecallScheduleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecallSchedulePayload>[]
        }
        upsert: {
          args: Prisma.RecallScheduleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecallSchedulePayload>
        }
        aggregate: {
          args: Prisma.RecallScheduleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRecallSchedule>
        }
        groupBy: {
          args: Prisma.RecallScheduleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RecallScheduleGroupByOutputType>[]
        }
        count: {
          args: Prisma.RecallScheduleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RecallScheduleCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const PracticeScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  agbCode: 'agbCode',
  kvkNumber: 'kvkNumber',
  avgCode: 'avgCode',
  addressStreet: 'addressStreet',
  addressCity: 'addressCity',
  addressPostal: 'addressPostal',
  phone: 'phone',
  email: 'email',
  vecozoCertRef: 'vecozoCertRef',
  billingConfig: 'billingConfig',
  settings: 'settings',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PracticeScalarFieldEnum = (typeof PracticeScalarFieldEnum)[keyof typeof PracticeScalarFieldEnum]


export const UserScalarFieldEnum = {
  id: 'id',
  keycloakId: 'keycloakId',
  practiceId: 'practiceId',
  email: 'email',
  passwordHash: 'passwordHash',
  firstName: 'firstName',
  lastName: 'lastName',
  role: 'role',
  bigNumber: 'bigNumber',
  agbCode: 'agbCode',
  specialization: 'specialization',
  phone: 'phone',
  isActive: 'isActive',
  lastLoginAt: 'lastLoginAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  dashboardLayout: 'dashboardLayout'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const PatientScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  userId: 'userId',
  patientNumber: 'patientNumber',
  bsn: 'bsn',
  bsnEncrypted: 'bsnEncrypted',
  bsnHash: 'bsnHash',
  bsnKeyVersion: 'bsnKeyVersion',
  firstName: 'firstName',
  lastName: 'lastName',
  dateOfBirth: 'dateOfBirth',
  gender: 'gender',
  email: 'email',
  phone: 'phone',
  addressStreet: 'addressStreet',
  addressCity: 'addressCity',
  addressPostal: 'addressPostal',
  insuranceCompany: 'insuranceCompany',
  insuranceNumber: 'insuranceNumber',
  insuranceType: 'insuranceType',
  insuranceVerifiedAt: 'insuranceVerifiedAt',
  medicalAlerts: 'medicalAlerts',
  medications: 'medications',
  bloodType: 'bloodType',
  referralSource: 'referralSource',
  gdprConsentAt: 'gdprConsentAt',
  dataRetentionUntil: 'dataRetentionUntil',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  emailPreferences: 'emailPreferences'
} as const

export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


export const ToothScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  toothNumber: 'toothNumber',
  status: 'status',
  isPrimary: 'isPrimary',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ToothScalarFieldEnum = (typeof ToothScalarFieldEnum)[keyof typeof ToothScalarFieldEnum]


export const ToothSurfaceScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  toothId: 'toothId',
  surface: 'surface',
  condition: 'condition',
  material: 'material',
  restorationType: 'restorationType',
  treatmentId: 'treatmentId',
  recordedAt: 'recordedAt',
  recordedBy: 'recordedBy'
} as const

export type ToothSurfaceScalarFieldEnum = (typeof ToothSurfaceScalarFieldEnum)[keyof typeof ToothSurfaceScalarFieldEnum]


export const TreatmentPlanScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  createdBy: 'createdBy',
  title: 'title',
  description: 'description',
  status: 'status',
  proposedAt: 'proposedAt',
  acceptedAt: 'acceptedAt',
  totalEstimate: 'totalEstimate',
  insuranceEstimate: 'insuranceEstimate',
  patientEstimate: 'patientEstimate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TreatmentPlanScalarFieldEnum = (typeof TreatmentPlanScalarFieldEnum)[keyof typeof TreatmentPlanScalarFieldEnum]


export const TreatmentScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  treatmentPlanId: 'treatmentPlanId',
  appointmentId: 'appointmentId',
  performedBy: 'performedBy',
  toothId: 'toothId',
  nzaCodeId: 'nzaCodeId',
  description: 'description',
  status: 'status',
  performedAt: 'performedAt',
  durationMinutes: 'durationMinutes',
  quantity: 'quantity',
  unitPrice: 'unitPrice',
  totalPrice: 'totalPrice',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TreatmentScalarFieldEnum = (typeof TreatmentScalarFieldEnum)[keyof typeof TreatmentScalarFieldEnum]


export const ClinicalNoteScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  appointmentId: 'appointmentId',
  authorId: 'authorId',
  noteType: 'noteType',
  content: 'content',
  isConfidential: 'isConfidential',
  createdAt: 'createdAt'
} as const

export type ClinicalNoteScalarFieldEnum = (typeof ClinicalNoteScalarFieldEnum)[keyof typeof ClinicalNoteScalarFieldEnum]


export const NoteFlagScalarFieldEnum = {
  id: 'id',
  noteId: 'noteId',
  flagType: 'flagType',
  comment: 'comment',
  createdById: 'createdById',
  createdAt: 'createdAt'
} as const

export type NoteFlagScalarFieldEnum = (typeof NoteFlagScalarFieldEnum)[keyof typeof NoteFlagScalarFieldEnum]


export const AppointmentScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  practitionerId: 'practitionerId',
  startTime: 'startTime',
  endTime: 'endTime',
  durationMinutes: 'durationMinutes',
  appointmentType: 'appointmentType',
  status: 'status',
  room: 'room',
  notes: 'notes',
  patientNotes: 'patientNotes',
  reminderSentAt: 'reminderSentAt',
  confirmationSentAt: 'confirmationSentAt',
  cancelledAt: 'cancelledAt',
  cancelReason: 'cancelReason',
  recurringRule: 'recurringRule',
  parentId: 'parentId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


export const PractitionerScheduleScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  practitionerId: 'practitionerId',
  dayOfWeek: 'dayOfWeek',
  startTime: 'startTime',
  endTime: 'endTime',
  slotDuration: 'slotDuration',
  isActive: 'isActive',
  validFrom: 'validFrom',
  validUntil: 'validUntil',
  createdAt: 'createdAt'
} as const

export type PractitionerScheduleScalarFieldEnum = (typeof PractitionerScheduleScalarFieldEnum)[keyof typeof PractitionerScheduleScalarFieldEnum]


export const ScheduleExceptionScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  practitionerId: 'practitionerId',
  exceptionDate: 'exceptionDate',
  exceptionType: 'exceptionType',
  startTime: 'startTime',
  endTime: 'endTime',
  reason: 'reason',
  createdAt: 'createdAt'
} as const

export type ScheduleExceptionScalarFieldEnum = (typeof ScheduleExceptionScalarFieldEnum)[keyof typeof ScheduleExceptionScalarFieldEnum]


export const NzaCodeScalarFieldEnum = {
  id: 'id',
  code: 'code',
  category: 'category',
  descriptionNl: 'descriptionNl',
  descriptionEn: 'descriptionEn',
  maxTariff: 'maxTariff',
  unit: 'unit',
  requiresTooth: 'requiresTooth',
  requiresSurface: 'requiresSurface',
  validFrom: 'validFrom',
  validUntil: 'validUntil',
  subcategory: 'subcategory',
  toelichting: 'toelichting',
  points: 'points',
  isActive: 'isActive',
  createdAt: 'createdAt'
} as const

export type NzaCodeScalarFieldEnum = (typeof NzaCodeScalarFieldEnum)[keyof typeof NzaCodeScalarFieldEnum]


export const InvoiceScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  invoiceNumber: 'invoiceNumber',
  invoiceDate: 'invoiceDate',
  dueDate: 'dueDate',
  subtotal: 'subtotal',
  taxAmount: 'taxAmount',
  total: 'total',
  insuranceAmount: 'insuranceAmount',
  patientAmount: 'patientAmount',
  status: 'status',
  paidAmount: 'paidAmount',
  paymentMethod: 'paymentMethod',
  claimStatus: 'claimStatus',
  claimReference: 'claimReference',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


export const InvoiceLineScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  invoiceId: 'invoiceId',
  treatmentId: 'treatmentId',
  nzaCodeId: 'nzaCodeId',
  description: 'description',
  nzaCode: 'nzaCode',
  toothNumber: 'toothNumber',
  surface: 'surface',
  quantity: 'quantity',
  unitPrice: 'unitPrice',
  lineTotal: 'lineTotal',
  sortOrder: 'sortOrder',
  createdAt: 'createdAt'
} as const

export type InvoiceLineScalarFieldEnum = (typeof InvoiceLineScalarFieldEnum)[keyof typeof InvoiceLineScalarFieldEnum]


export const PaymentScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  invoiceId: 'invoiceId',
  amount: 'amount',
  method: 'method',
  status: 'status',
  molliePaymentId: 'molliePaymentId',
  mollieStatus: 'mollieStatus',
  mollieCheckoutUrl: 'mollieCheckoutUrl',
  paidAt: 'paidAt',
  refundedAt: 'refundedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


export const InsuranceClaimScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  invoiceId: 'invoiceId',
  uzoviCode: 'uzoviCode',
  claimNumber: 'claimNumber',
  claimData: 'claimData',
  status: 'status',
  submittedAt: 'submittedAt',
  responseAt: 'responseAt',
  responseData: 'responseData',
  rejectionReason: 'rejectionReason',
  amountClaimed: 'amountClaimed',
  amountApproved: 'amountApproved',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InsuranceClaimScalarFieldEnum = (typeof InsuranceClaimScalarFieldEnum)[keyof typeof InsuranceClaimScalarFieldEnum]


export const ConsentTemplateScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  title: 'title',
  contentNl: 'contentNl',
  contentEn: 'contentEn',
  consentType: 'consentType',
  isActive: 'isActive',
  expiryDays: 'expiryDays',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConsentTemplateScalarFieldEnum = (typeof ConsentTemplateScalarFieldEnum)[keyof typeof ConsentTemplateScalarFieldEnum]


export const ConsentFormScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  consentType: 'consentType',
  treatmentType: 'treatmentType',
  title: 'title',
  content: 'content',
  treatmentPlanId: 'treatmentPlanId',
  templateId: 'templateId',
  description: 'description',
  signedAt: 'signedAt',
  signatureData: 'signatureData',
  signedByName: 'signedByName',
  signedIp: 'signedIp',
  signedUserAgent: 'signedUserAgent',
  signerRelation: 'signerRelation',
  signatureUrl: 'signatureUrl',
  documentUrl: 'documentUrl',
  emailSentAt: 'emailSentAt',
  emailAddress: 'emailAddress',
  appointmentId: 'appointmentId',
  version: 'version',
  language: 'language',
  status: 'status',
  expiresAt: 'expiresAt',
  revokedAt: 'revokedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConsentFormScalarFieldEnum = (typeof ConsentFormScalarFieldEnum)[keyof typeof ConsentFormScalarFieldEnum]


export const DocumentScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  uploadedBy: 'uploadedBy',
  documentType: 'documentType',
  title: 'title',
  description: 'description',
  s3Bucket: 's3Bucket',
  s3Key: 's3Key',
  fileSize: 'fileSize',
  mimeType: 'mimeType',
  toothNumber: 'toothNumber',
  imageType: 'imageType',
  isArchived: 'isArchived',
  uploadedByPatientId: 'uploadedByPatientId',
  approvalStatus: 'approvalStatus',
  createdAt: 'createdAt'
} as const

export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


export const AuditLogScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  userId: 'userId',
  action: 'action',
  resourceType: 'resourceType',
  resourceId: 'resourceId',
  oldValues: 'oldValues',
  newValues: 'newValues',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  sessionId: 'sessionId',
  bsnAccessed: 'bsnAccessed',
  bsnAccessReason: 'bsnAccessReason',
  createdAt: 'createdAt'
} as const

export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


export const NotificationScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  userId: 'userId',
  patientId: 'patientId',
  channel: 'channel',
  template: 'template',
  subject: 'subject',
  content: 'content',
  status: 'status',
  sentAt: 'sentAt',
  readAt: 'readAt',
  externalId: 'externalId',
  errorMessage: 'errorMessage',
  metadata: 'metadata',
  createdAt: 'createdAt'
} as const

export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


export const CredentialScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  name: 'name',
  type: 'type',
  environment: 'environment',
  apiKey: 'apiKey',
  apiSecret: 'apiSecret',
  accessToken: 'accessToken',
  refreshToken: 'refreshToken',
  config: 'config',
  isActive: 'isActive',
  isTestMode: 'isTestMode',
  lastUsedAt: 'lastUsedAt',
  expiresAt: 'expiresAt',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CredentialScalarFieldEnum = (typeof CredentialScalarFieldEnum)[keyof typeof CredentialScalarFieldEnum]


export const PrescriptionScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  appointmentId: 'appointmentId',
  prescribedBy: 'prescribedBy',
  medicationName: 'medicationName',
  genericName: 'genericName',
  dosage: 'dosage',
  frequency: 'frequency',
  duration: 'duration',
  quantity: 'quantity',
  route: 'route',
  instructions: 'instructions',
  status: 'status',
  prescribedAt: 'prescribedAt',
  discontinuedAt: 'discontinuedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PrescriptionScalarFieldEnum = (typeof PrescriptionScalarFieldEnum)[keyof typeof PrescriptionScalarFieldEnum]


export const PeriodontalChartScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  appointmentId: 'appointmentId',
  authorId: 'authorId',
  chartData: 'chartData',
  sessionNote: 'sessionNote',
  createdAt: 'createdAt'
} as const

export type PeriodontalChartScalarFieldEnum = (typeof PeriodontalChartScalarFieldEnum)[keyof typeof PeriodontalChartScalarFieldEnum]


export const PatientImageScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  uploadedBy: 'uploadedBy',
  fileName: 'fileName',
  filePath: 'filePath',
  fileSize: 'fileSize',
  mimeType: 'mimeType',
  imageType: 'imageType',
  notes: 'notes',
  createdAt: 'createdAt'
} as const

export type PatientImageScalarFieldEnum = (typeof PatientImageScalarFieldEnum)[keyof typeof PatientImageScalarFieldEnum]


export const AnamnesisScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  version: 'version',
  data: 'data',
  completedAt: 'completedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AnamnesisScalarFieldEnum = (typeof AnamnesisScalarFieldEnum)[keyof typeof AnamnesisScalarFieldEnum]


export const MessageScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  senderId: 'senderId',
  senderType: 'senderType',
  content: 'content',
  isRead: 'isRead',
  readAt: 'readAt',
  createdAt: 'createdAt'
} as const

export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


export const ReferralScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  createdBy: 'createdBy',
  specialistType: 'specialistType',
  specialistName: 'specialistName',
  specialistPractice: 'specialistPractice',
  specialistPhone: 'specialistPhone',
  specialistEmail: 'specialistEmail',
  reason: 'reason',
  clinicalInfo: 'clinicalInfo',
  urgency: 'urgency',
  status: 'status',
  referralDate: 'referralDate',
  appointmentMadeAt: 'appointmentMadeAt',
  completedAt: 'completedAt',
  pdfUrl: 'pdfUrl',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ReferralScalarFieldEnum = (typeof ReferralScalarFieldEnum)[keyof typeof ReferralScalarFieldEnum]


export const ComplaintScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  type: 'type',
  subject: 'subject',
  description: 'description',
  attachmentUrl: 'attachmentUrl',
  anonymous: 'anonymous',
  referenceNumber: 'referenceNumber',
  status: 'status',
  response: 'response',
  resolvedAt: 'resolvedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ComplaintScalarFieldEnum = (typeof ComplaintScalarFieldEnum)[keyof typeof ComplaintScalarFieldEnum]


export const EmailThreadScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  gmailThreadId: 'gmailThreadId',
  gmailMessageIds: 'gmailMessageIds',
  subject: 'subject',
  participants: 'participants',
  lastMessageAt: 'lastMessageAt',
  patientId: 'patientId',
  isUnread: 'isUnread',
  isStarred: 'isStarred',
  labels: 'labels',
  snippet: 'snippet',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EmailThreadScalarFieldEnum = (typeof EmailThreadScalarFieldEnum)[keyof typeof EmailThreadScalarFieldEnum]


export const EmailMessageScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  threadId: 'threadId',
  gmailMessageId: 'gmailMessageId',
  from: 'from',
  to: 'to',
  cc: 'cc',
  bcc: 'bcc',
  subject: 'subject',
  bodyHtml: 'bodyHtml',
  bodyText: 'bodyText',
  snippet: 'snippet',
  attachments: 'attachments',
  isUnread: 'isUnread',
  isStarred: 'isStarred',
  labels: 'labels',
  internalDate: 'internalDate',
  createdAt: 'createdAt'
} as const

export type EmailMessageScalarFieldEnum = (typeof EmailMessageScalarFieldEnum)[keyof typeof EmailMessageScalarFieldEnum]


export const WhatsAppConversationScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  phoneNumber: 'phoneNumber',
  lastMessageAt: 'lastMessageAt',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type WhatsAppConversationScalarFieldEnum = (typeof WhatsAppConversationScalarFieldEnum)[keyof typeof WhatsAppConversationScalarFieldEnum]


export const WhatsAppMessageScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  conversationId: 'conversationId',
  twilioSid: 'twilioSid',
  direction: 'direction',
  from: 'from',
  to: 'to',
  body: 'body',
  mediaUrl: 'mediaUrl',
  mediaType: 'mediaType',
  status: 'status',
  errorCode: 'errorCode',
  errorMessage: 'errorMessage',
  sentBy: 'sentBy',
  createdAt: 'createdAt'
} as const

export type WhatsAppMessageScalarFieldEnum = (typeof WhatsAppMessageScalarFieldEnum)[keyof typeof WhatsAppMessageScalarFieldEnum]


export const PatientCategoryScalarFieldEnum = {
  id: 'id',
  patientId: 'patientId',
  category: 'category',
  assignedAt: 'assignedAt'
} as const

export type PatientCategoryScalarFieldEnum = (typeof PatientCategoryScalarFieldEnum)[keyof typeof PatientCategoryScalarFieldEnum]


export const CustomCodeCategoryScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  practiceId: 'practiceId',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CustomCodeCategoryScalarFieldEnum = (typeof CustomCodeCategoryScalarFieldEnum)[keyof typeof CustomCodeCategoryScalarFieldEnum]


export const CustomCodeCategoryCodeScalarFieldEnum = {
  id: 'id',
  categoryId: 'categoryId',
  nzaCodeId: 'nzaCodeId'
} as const

export type CustomCodeCategoryCodeScalarFieldEnum = (typeof CustomCodeCategoryCodeScalarFieldEnum)[keyof typeof CustomCodeCategoryCodeScalarFieldEnum]


export const DsdDesignScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  createdBy: 'createdBy',
  title: 'title',
  status: 'status',
  imageId: 'imageId',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DsdDesignScalarFieldEnum = (typeof DsdDesignScalarFieldEnum)[keyof typeof DsdDesignScalarFieldEnum]


export const DsdDesignVersionScalarFieldEnum = {
  id: 'id',
  designId: 'designId',
  versionNumber: 'versionNumber',
  createdBy: 'createdBy',
  notes: 'notes',
  landmarkData: 'landmarkData',
  calibrationData: 'calibrationData',
  measurements: 'measurements',
  derivedLines: 'derivedLines',
  stlFileUrl: 'stlFileUrl',
  stlFileName: 'stlFileName',
  createdAt: 'createdAt'
} as const

export type DsdDesignVersionScalarFieldEnum = (typeof DsdDesignVersionScalarFieldEnum)[keyof typeof DsdDesignVersionScalarFieldEnum]


export const ConversationScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  practitionerId: 'practitionerId',
  subject: 'subject',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


export const ConversationMessageScalarFieldEnum = {
  id: 'id',
  conversationId: 'conversationId',
  senderType: 'senderType',
  senderId: 'senderId',
  content: 'content',
  isRead: 'isRead',
  createdAt: 'createdAt'
} as const

export type ConversationMessageScalarFieldEnum = (typeof ConversationMessageScalarFieldEnum)[keyof typeof ConversationMessageScalarFieldEnum]


export const MessageAttachmentScalarFieldEnum = {
  id: 'id',
  messageId: 'messageId',
  fileName: 'fileName',
  fileUrl: 'fileUrl',
  fileSize: 'fileSize',
  mimeType: 'mimeType',
  createdAt: 'createdAt'
} as const

export type MessageAttachmentScalarFieldEnum = (typeof MessageAttachmentScalarFieldEnum)[keyof typeof MessageAttachmentScalarFieldEnum]


export const DentistTaskScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  userId: 'userId',
  patientId: 'patientId',
  title: 'title',
  description: 'description',
  category: 'category',
  targetType: 'targetType',
  targetId: 'targetId',
  dueDate: 'dueDate',
  priority: 'priority',
  status: 'status',
  completedAt: 'completedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DentistTaskScalarFieldEnum = (typeof DentistTaskScalarFieldEnum)[keyof typeof DentistTaskScalarFieldEnum]


export const AiChatSessionScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  title: 'title',
  metadata: 'metadata',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AiChatSessionScalarFieldEnum = (typeof AiChatSessionScalarFieldEnum)[keyof typeof AiChatSessionScalarFieldEnum]


export const AiChatMessageScalarFieldEnum = {
  id: 'id',
  sessionId: 'sessionId',
  role: 'role',
  content: 'content',
  richCards: 'richCards',
  feedback: 'feedback',
  createdAt: 'createdAt'
} as const

export type AiChatMessageScalarFieldEnum = (typeof AiChatMessageScalarFieldEnum)[keyof typeof AiChatMessageScalarFieldEnum]


export const PatientNudgeScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  nudgeType: 'nudgeType',
  channel: 'channel',
  message: 'message',
  sentAt: 'sentAt',
  clickedAt: 'clickedAt',
  bookedAt: 'bookedAt',
  metadata: 'metadata'
} as const

export type PatientNudgeScalarFieldEnum = (typeof PatientNudgeScalarFieldEnum)[keyof typeof PatientNudgeScalarFieldEnum]


export const StaffChatScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  name: 'name',
  isGroup: 'isGroup',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type StaffChatScalarFieldEnum = (typeof StaffChatScalarFieldEnum)[keyof typeof StaffChatScalarFieldEnum]


export const StaffChatMemberScalarFieldEnum = {
  id: 'id',
  chatId: 'chatId',
  userId: 'userId',
  joinedAt: 'joinedAt'
} as const

export type StaffChatMemberScalarFieldEnum = (typeof StaffChatMemberScalarFieldEnum)[keyof typeof StaffChatMemberScalarFieldEnum]


export const StaffChatMessageScalarFieldEnum = {
  id: 'id',
  chatId: 'chatId',
  senderId: 'senderId',
  content: 'content',
  isRead: 'isRead',
  createdAt: 'createdAt'
} as const

export type StaffChatMessageScalarFieldEnum = (typeof StaffChatMessageScalarFieldEnum)[keyof typeof StaffChatMessageScalarFieldEnum]


export const PerioSessionScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  appointmentId: 'appointmentId',
  authorId: 'authorId',
  sessionType: 'sessionType',
  sessionNote: 'sessionNote',
  protocolId: 'protocolId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PerioSessionScalarFieldEnum = (typeof PerioSessionScalarFieldEnum)[keyof typeof PerioSessionScalarFieldEnum]


export const PerioSiteScalarFieldEnum = {
  id: 'id',
  sessionId: 'sessionId',
  toothNumber: 'toothNumber',
  surface: 'surface',
  sitePosition: 'sitePosition',
  probingDepth: 'probingDepth',
  gingivalMargin: 'gingivalMargin',
  bleeding: 'bleeding',
  plaque: 'plaque',
  suppuration: 'suppuration',
  mobility: 'mobility',
  furcationGrade: 'furcationGrade',
  isImplant: 'isImplant',
  toothNote: 'toothNote',
  keratinizedWidth: 'keratinizedWidth'
} as const

export type PerioSiteScalarFieldEnum = (typeof PerioSiteScalarFieldEnum)[keyof typeof PerioSiteScalarFieldEnum]


export const PerioProtocolScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  status: 'status',
  steps: 'steps',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PerioProtocolScalarFieldEnum = (typeof PerioProtocolScalarFieldEnum)[keyof typeof PerioProtocolScalarFieldEnum]


export const RecallScheduleScalarFieldEnum = {
  id: 'id',
  practiceId: 'practiceId',
  patientId: 'patientId',
  intervalMonths: 'intervalMonths',
  nextDueDate: 'nextDueDate',
  status: 'status',
  lastCompletedAt: 'lastCompletedAt',
  reminderSentAt: 'reminderSentAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RecallScheduleScalarFieldEnum = (typeof RecallScheduleScalarFieldEnum)[keyof typeof RecallScheduleScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'UserRole'
 */
export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


/**
 * Reference to a field of type 'UserRole[]'
 */
export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


/**
 * Reference to a field of type 'Bytes'
 */
export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


/**
 * Reference to a field of type 'Bytes[]'
 */
export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'ToothStatus'
 */
export type EnumToothStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ToothStatus'>
    


/**
 * Reference to a field of type 'ToothStatus[]'
 */
export type ListEnumToothStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ToothStatus[]'>
    


/**
 * Reference to a field of type 'SurfaceCondition'
 */
export type EnumSurfaceConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SurfaceCondition'>
    


/**
 * Reference to a field of type 'SurfaceCondition[]'
 */
export type ListEnumSurfaceConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SurfaceCondition[]'>
    


/**
 * Reference to a field of type 'Material'
 */
export type EnumMaterialFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Material'>
    


/**
 * Reference to a field of type 'Material[]'
 */
export type ListEnumMaterialFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Material[]'>
    


/**
 * Reference to a field of type 'RestorationType'
 */
export type EnumRestorationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RestorationType'>
    


/**
 * Reference to a field of type 'RestorationType[]'
 */
export type ListEnumRestorationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RestorationType[]'>
    


/**
 * Reference to a field of type 'TreatmentPlanStatus'
 */
export type EnumTreatmentPlanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TreatmentPlanStatus'>
    


/**
 * Reference to a field of type 'TreatmentPlanStatus[]'
 */
export type ListEnumTreatmentPlanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TreatmentPlanStatus[]'>
    


/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


/**
 * Reference to a field of type 'Decimal[]'
 */
export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


/**
 * Reference to a field of type 'TreatmentStatus'
 */
export type EnumTreatmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TreatmentStatus'>
    


/**
 * Reference to a field of type 'TreatmentStatus[]'
 */
export type ListEnumTreatmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TreatmentStatus[]'>
    


/**
 * Reference to a field of type 'NoteType'
 */
export type EnumNoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteType'>
    


/**
 * Reference to a field of type 'NoteType[]'
 */
export type ListEnumNoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteType[]'>
    


/**
 * Reference to a field of type 'AppointmentType'
 */
export type EnumAppointmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentType'>
    


/**
 * Reference to a field of type 'AppointmentType[]'
 */
export type ListEnumAppointmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentType[]'>
    


/**
 * Reference to a field of type 'AppointmentStatus'
 */
export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


/**
 * Reference to a field of type 'AppointmentStatus[]'
 */
export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>
    


/**
 * Reference to a field of type 'ExceptionType'
 */
export type EnumExceptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExceptionType'>
    


/**
 * Reference to a field of type 'ExceptionType[]'
 */
export type ListEnumExceptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExceptionType[]'>
    


/**
 * Reference to a field of type 'InvoiceStatus'
 */
export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


/**
 * Reference to a field of type 'InvoiceStatus[]'
 */
export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


/**
 * Reference to a field of type 'PaymentMethod'
 */
export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


/**
 * Reference to a field of type 'PaymentMethod[]'
 */
export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


/**
 * Reference to a field of type 'PaymentStatus'
 */
export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


/**
 * Reference to a field of type 'PaymentStatus[]'
 */
export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


/**
 * Reference to a field of type 'ClaimStatus'
 */
export type EnumClaimStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimStatus'>
    


/**
 * Reference to a field of type 'ClaimStatus[]'
 */
export type ListEnumClaimStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimStatus[]'>
    


/**
 * Reference to a field of type 'BigInt'
 */
export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


/**
 * Reference to a field of type 'BigInt[]'
 */
export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


/**
 * Reference to a field of type 'DocumentApprovalStatus'
 */
export type EnumDocumentApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentApprovalStatus'>
    


/**
 * Reference to a field of type 'DocumentApprovalStatus[]'
 */
export type ListEnumDocumentApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentApprovalStatus[]'>
    


/**
 * Reference to a field of type 'NotificationChannel'
 */
export type EnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel'>
    


/**
 * Reference to a field of type 'NotificationChannel[]'
 */
export type ListEnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel[]'>
    


/**
 * Reference to a field of type 'NotificationStatus'
 */
export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


/**
 * Reference to a field of type 'NotificationStatus[]'
 */
export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    


/**
 * Reference to a field of type 'CredentialType'
 */
export type EnumCredentialTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CredentialType'>
    


/**
 * Reference to a field of type 'CredentialType[]'
 */
export type ListEnumCredentialTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CredentialType[]'>
    


/**
 * Reference to a field of type 'PrescriptionStatus'
 */
export type EnumPrescriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrescriptionStatus'>
    


/**
 * Reference to a field of type 'PrescriptionStatus[]'
 */
export type ListEnumPrescriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrescriptionStatus[]'>
    


/**
 * Reference to a field of type 'SenderType'
 */
export type EnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType'>
    


/**
 * Reference to a field of type 'SenderType[]'
 */
export type ListEnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType[]'>
    


/**
 * Reference to a field of type 'ReferralUrgency'
 */
export type EnumReferralUrgencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReferralUrgency'>
    


/**
 * Reference to a field of type 'ReferralUrgency[]'
 */
export type ListEnumReferralUrgencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReferralUrgency[]'>
    


/**
 * Reference to a field of type 'ReferralStatus'
 */
export type EnumReferralStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReferralStatus'>
    


/**
 * Reference to a field of type 'ReferralStatus[]'
 */
export type ListEnumReferralStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReferralStatus[]'>
    


/**
 * Reference to a field of type 'ComplaintType'
 */
export type EnumComplaintTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintType'>
    


/**
 * Reference to a field of type 'ComplaintType[]'
 */
export type ListEnumComplaintTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintType[]'>
    


/**
 * Reference to a field of type 'ComplaintSubject'
 */
export type EnumComplaintSubjectFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintSubject'>
    


/**
 * Reference to a field of type 'ComplaintSubject[]'
 */
export type ListEnumComplaintSubjectFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintSubject[]'>
    


/**
 * Reference to a field of type 'ComplaintStatus'
 */
export type EnumComplaintStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintStatus'>
    


/**
 * Reference to a field of type 'ComplaintStatus[]'
 */
export type ListEnumComplaintStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintStatus[]'>
    


/**
 * Reference to a field of type 'DsdStatus'
 */
export type EnumDsdStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DsdStatus'>
    


/**
 * Reference to a field of type 'DsdStatus[]'
 */
export type ListEnumDsdStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DsdStatus[]'>
    


/**
 * Reference to a field of type 'ConversationStatus'
 */
export type EnumConversationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversationStatus'>
    


/**
 * Reference to a field of type 'ConversationStatus[]'
 */
export type ListEnumConversationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversationStatus[]'>
    


/**
 * Reference to a field of type 'TaskCategory'
 */
export type EnumTaskCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskCategory'>
    


/**
 * Reference to a field of type 'TaskCategory[]'
 */
export type ListEnumTaskCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskCategory[]'>
    


/**
 * Reference to a field of type 'TaskPriority'
 */
export type EnumTaskPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskPriority'>
    


/**
 * Reference to a field of type 'TaskPriority[]'
 */
export type ListEnumTaskPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskPriority[]'>
    


/**
 * Reference to a field of type 'TaskStatus'
 */
export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


/**
 * Reference to a field of type 'TaskStatus[]'
 */
export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


/**
 * Reference to a field of type 'PerioSessionType'
 */
export type EnumPerioSessionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PerioSessionType'>
    


/**
 * Reference to a field of type 'PerioSessionType[]'
 */
export type ListEnumPerioSessionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PerioSessionType[]'>
    


/**
 * Reference to a field of type 'PerioProtocolStatus'
 */
export type EnumPerioProtocolStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PerioProtocolStatus'>
    


/**
 * Reference to a field of type 'PerioProtocolStatus[]'
 */
export type ListEnumPerioProtocolStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PerioProtocolStatus[]'>
    


/**
 * Reference to a field of type 'RecallStatus'
 */
export type EnumRecallStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecallStatus'>
    


/**
 * Reference to a field of type 'RecallStatus[]'
 */
export type ListEnumRecallStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecallStatus[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  practice?: Prisma.PracticeOmit
  user?: Prisma.UserOmit
  patient?: Prisma.PatientOmit
  tooth?: Prisma.ToothOmit
  toothSurface?: Prisma.ToothSurfaceOmit
  treatmentPlan?: Prisma.TreatmentPlanOmit
  treatment?: Prisma.TreatmentOmit
  clinicalNote?: Prisma.ClinicalNoteOmit
  noteFlag?: Prisma.NoteFlagOmit
  appointment?: Prisma.AppointmentOmit
  practitionerSchedule?: Prisma.PractitionerScheduleOmit
  scheduleException?: Prisma.ScheduleExceptionOmit
  nzaCode?: Prisma.NzaCodeOmit
  invoice?: Prisma.InvoiceOmit
  invoiceLine?: Prisma.InvoiceLineOmit
  payment?: Prisma.PaymentOmit
  insuranceClaim?: Prisma.InsuranceClaimOmit
  consentTemplate?: Prisma.ConsentTemplateOmit
  consentForm?: Prisma.ConsentFormOmit
  document?: Prisma.DocumentOmit
  auditLog?: Prisma.AuditLogOmit
  notification?: Prisma.NotificationOmit
  credential?: Prisma.CredentialOmit
  prescription?: Prisma.PrescriptionOmit
  periodontalChart?: Prisma.PeriodontalChartOmit
  patientImage?: Prisma.PatientImageOmit
  anamnesis?: Prisma.AnamnesisOmit
  message?: Prisma.MessageOmit
  referral?: Prisma.ReferralOmit
  complaint?: Prisma.ComplaintOmit
  emailThread?: Prisma.EmailThreadOmit
  emailMessage?: Prisma.EmailMessageOmit
  whatsAppConversation?: Prisma.WhatsAppConversationOmit
  whatsAppMessage?: Prisma.WhatsAppMessageOmit
  patientCategory?: Prisma.PatientCategoryOmit
  customCodeCategory?: Prisma.CustomCodeCategoryOmit
  customCodeCategoryCode?: Prisma.CustomCodeCategoryCodeOmit
  dsdDesign?: Prisma.DsdDesignOmit
  dsdDesignVersion?: Prisma.DsdDesignVersionOmit
  conversation?: Prisma.ConversationOmit
  conversationMessage?: Prisma.ConversationMessageOmit
  messageAttachment?: Prisma.MessageAttachmentOmit
  dentistTask?: Prisma.DentistTaskOmit
  aiChatSession?: Prisma.AiChatSessionOmit
  aiChatMessage?: Prisma.AiChatMessageOmit
  patientNudge?: Prisma.PatientNudgeOmit
  staffChat?: Prisma.StaffChatOmit
  staffChatMember?: Prisma.StaffChatMemberOmit
  staffChatMessage?: Prisma.StaffChatMessageOmit
  perioSession?: Prisma.PerioSessionOmit
  perioSite?: Prisma.PerioSiteOmit
  perioProtocol?: Prisma.PerioProtocolOmit
  recallSchedule?: Prisma.RecallScheduleOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

